<html lang="ru">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="../assets/styles/style.css"/>
    <title>К ЛР № 4 по «ТП» 16.12.2016 | Кафедра управления и информатики</title>
</head>
<body>

<h1>План ЛР № 4 по «Технологии программирования» 16 декабря 2016 г.</h1>

<p class="alert">
    Это не задание, это «прохождение» первой половины ЛР&nbsp;№&nbsp;4
    и&nbsp;вспомогательные материалы ко&nbsp;второй половине.
    Фрагменты кода могут содержать ошибки (не&nbsp;специально).
</p>

<h2>1. Функции <code>print_in_*()</code> (под руководством)</h2>

<p>Разобьем задачу на более простые части.</p>

<p>Начнем с <code>print_in_hex()</code>.  Байт — это 8 бит, то есть две цифры
в шестнадцатеричной системе.  Чтобы напечатать байт, нужно напечатать цифру,
соответствующую его старшей и младшей половине (они называются nibble).
Любой блок данных (по адресу в нетипизированном указателе <code>void*</code>) — это массив
байт; нужно только указать компилятору рассмотреть <code>void*</code> как <code>uint8_t*</code>.
Очевидно, чтобы напечатать массив байт, нужно напечатать каждый байт в цикле.</p>

<p>Перевод байта в двоичную запись можно делать целиком, дробить байт нет смысла.
Печать массива байт в двоичном виде по сути не отличается от печати их
в шестнадцатеричной системе счисления.</p>

<p>Итак, элементарные задачи:</p>

<ol>
<li>Напечатать шестнадцатеричную цифру для значения от 0 до 15.</li>
<li>Извлечь из байта младший nibble как число от 0 до 15.</li>
<li>Извлечь из байта старший nibble как число от 0 до 15.</li>
<li>Напечатать байт в шестнадцатеричном виде как два nibble.</li>
<li>Преобразовать <code>void*</code> в <code>uint8_t*</code>.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (hex).</li>
<li>Напечатать байт в двоичном виде.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (binary).</li>
</ol>

<h3>1.1. Напечатать шестнадцатеричную цифру для значения от 0 до 15</h3>

<p>Напишем вспомогательную функцию, которая будет представлять значение от 0 до 15
в шестнадцатеричном виде.  Что она принимает?  Целое число от 0 до 15,
для этого достаточно <code>uint8_t</code>.  Что она возвращает?  Можно сразу печатать
результат, тогда не нужно возвращать ничего (<code>void</code>).  Но вспомним, что функции
желательно делать максимально пригодными для повторного использования, и вовсе
не всегда нужно печатать nibble не экране.  Поэтому лучше возвращать символ
для nibble, то есть <code>char</code>.  Итого: <code>char nibble_to_hex(uint8_t i);</code>.</p>

<p>Как реализовать <code>nibble_to_hex()</code>?  Очевидный вариант — через <code>switch</code>
на 16 вариантов.  Есть и более лаконичный вариант: заведем массив цифр
<code>char digits[] = "0123456789abcdef";</code> и будет для значения <code>i</code> возвращать
<code>digits[i]</code>.  На практике популярен еще один вариант - через коды символов.
Вспомним, что символы в памяти хранятся как их коды, например, коды цифр
от <code>'0'</code> до <code>'9'</code> — от 48 до 57, а коды букв от <code>'a'</code> до <code>'f'</code> — от 97 до 102.
Таким образом, если <code>i</code> меньше 10, можно прибавить <code>i</code> к <code>'0'</code> и получить
соответствующую цифру; если <code>i</code> больше, нужно прибавить к <code>'a'</code> столько,
на сколько <code>i</code> больше 10 (то есть для 10 — 0, для 11 — 1 и т. д.).</p>

<p>Важный момент — самопроверка. В стандартном заголовочном файле <code>&lt;cassert&gt;</code>
есть полезный макрос <code>assert()</code>.  Если передать в <code>assert()</code> выражение,
и оно окажется ложным, программа аварийно завершится, и будет напечатано
это выражение.  Если же оно истинно, ничего сделано не будет.  Чтобы проверить
работу <code>nibble_to_hex()</code>, добавим в функцию <code>main()</code> 16 строк:</p>

<pre><code>assert(nibble_to_hex(0x0) == '0');
assert(nibble_to_hex(0x1) == '1');
// ...
assert(nibble_to_hex(0xf) == 'f');
</code></pre>

<p>При каждом запуске программы будет проверяться, что функция корректно
работает для всех цифр.</p>

<p>Еще один вопрос — реакция <code>nibble_to_hex()</code> на некорректные значения аргумента.
Можно решить его тем же <code>assert()</code>, добавив <code>assert(0x0 &lt;= i &amp;&amp; i &lt;= 0xf)</code>
в начало функции.</p>

<p><strong>На этом шаге каждый должен</strong> реализовать тот вариант, который приглянулся,
и проверить его работу.</p>

<h3>1.2. Извлечь из байта младший nibble как число от 0 до 15</h3>

<p>Задача сводится к тому, чтобы из восьми бит четыре младших оставить такими,
как есть, а четыре старших обнулить.  Типовое решение — наложить битовую маску.
Битовая маска следующая: <code>0b00001111</code>, или <code>0x0f</code>, — в ней единицы стоят в тех
позициях, биты в которых нужно извлечь.  Логическое «И» (<code>&amp;</code>) бита <code>x</code> с нулем
дает 0, а с единицей - <code>x</code>, то есть <code>byte &amp; mask</code> даст искомый младший nibble.
Решение для математиков — взять остаток от деления байта на 32 (<code>0b00010000</code>).</p>

<h3>1.3. Извлечь из байта старший nibble как число от 0 до 15</h3>

<p>Можно разбить эту задачу еще на две: выделение старших разрядов байта и их
перемещение (сдвиг) на позиции младших разрядов.  Какая маска подойдет
для выделения?  Очевидно, <code>0xf0</code> (<code>0b11110000</code>).  Сдвиг вправо на 4 разряда
делается оператором <code>&gt;&gt;</code>: <code>byte &gt;&gt; 4</code>.  По стандарту C++, старшие биты
результата будут равны 0, поэтому на самом деле выделять старшие биты
не нужно.  Сдвиг вправо на 4 позиции математически равносилен делению
на 2⁴, но при работе с битами сдвиг лучше выражает суть дела.</p>

<h3>1.4. Напечатать байт как два nibble</h3>

<p><strong>На этом шаге каждый должен</strong> реализовать <code>print_in_hex()</code> для байта:</p>

<pre><code>void
print_in_hex(uint8_t byte) {
    cout &lt;&lt; nibble_to_hex(byte &gt;&gt; 4)
         &lt;&lt; nibble_to_hex(byte &amp; 0xf);
}
</code></pre>

<p><strong>Для самопроверки</strong> следует попробовать напечатать байты <code>0x0</code>, <code>0xab</code>, <code>0xff</code>.</p>

<h3>1.5, 1.6. Преобразовать <code>void*</code> в <code>uint8_t*</code> и напечатать массив этих байт</h3>

<p>Заключим преобразование типов в функцию. В реальной программе это было бы
излишне, но функция — это ведь еще и помощь программисту в структурировании
программы, и раз так удобнее рассуждать, то и сделаем.</p>

<pre><code>const uint8_t* as_bytes(const void* data);
</code></pre>

<p>Здесь важны ключевые слова <code>const</code>.  Они означают, что данные по адресу,
хранимому в указателе, не могут быть изменены через этот указатель.</p>

<p>Считая, что она реализована, можно записать печать массива сразу:</p>

<pre><code>void
print_in_hex(const void* data, size_t size) {
    const uint8_t* bytes = as_bytes(data);
    for (size_t i = 0; i &lt; size; i++) {
        print_in_hex(bytes[i]);

        // Для удобства чтения: пробелы между байтам, по 16 байт на строку.
        if ((i + 1) % 16 == 0) {
            cout &lt;&lt; '\n';
        }
        else {
            cout &lt;&lt; ' ';
        }
    }
}
</code></pre>

<p>Указание компилятору, что значение одного типа нужно трактовать как значение
другого, называется приведением типов.  Из лекций известно, что в данном
случае корректна такая реализация:</p>

<pre><code>const uint8_t*
as_bytes(const void* data) {
    return reinterpret_cast&lt;const uint8_t*&gt;(data);
}
</code></pre>

<p><strong>На этом шаге каждый должен</strong> перенести код в свою программу.
<strong>Самопроверка:</strong> завести переменные типа <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>
и дать им одно и то же значение, <code>0x42</code>.  Напечатать их через новую функцию
и убедиться визуально, что единственным ненулевым байтом будет <code>0x42</code>
в каждом случае, а всего байт будет столько, сколько ожидается.
Вторым параметром следует передавать <code>sizeof</code>, например:</p>

<pre><code>uint32_t u32 = 0x42;
cout &lt;&lt; "u32 bytes: ";
print_in_hex(&amp;u32, sizeof(u32));
cout &lt;&lt; '\n';
</code></pre>

<h3>1.7. Напечатать байт в двоичном виде</h3>

<p>Известен способ перевода в двоичную систему путем взятия остатков от деления
на два, однако, порядок остатком получается обратным порядку бит.  В программе
проще проверять биты, начиная со старшего, и печатать <code>0</code>, если бит равен 0,
и <code>1</code>, если бит равен 1.  Для выделения бита можно воспользоваться маской:
старший бит выделяется как <code>0b10000000</code>, или <code>(0x1 &lt;&lt; 7)</code>, младший — маской
<code>(0x1 &lt;&lt; 0)</code>.  После наложения маски с одним установленным битом в результате
останется либо 0 (если соответствующий бит не установлен), либо не-ноль,
если установлен.  Выделим эту логику в функцию по аналогии с <code>nibble_to_hex()</code>:</p>

<pre><code>char
bit_digit(uint8_t byte, uint8_t bit) {
    if (byte &amp; (0x1 &lt;&lt; bit)) {
        return '1';
    }
    return '0';
}
</code></pre>

<p>Сдвиги на 7, 6, ..., 0 бит логично делать циклом. Итого:</p>

<pre><code>void
print_in_binary(uint8_t byte) {
    for (uint8_t bit = 7; bit &gt; 0; bit--) {
        cout &lt;&lt; bit_digit(byte, shift);
    }
}
</code></pre>

<p><strong>На этом шаге каждый должен</strong> перенести код в свою программу.
<strong>Самопроверка:</strong> перевести в двоичное представление и напечатать числа
из лекционного слайда про двоичные операции (исходные два числа
и результаты всех действий).</p>

<h3>1.8. Напечатать блок данных в двоичном виде</h3>

<p>Очевидно, что приведение типов не отличается от случая для шестнадцатеричной
системы.  <strong>Каждый должен</strong> написать и проверить по аналогии с <code>print_in_hex()</code>:</p>

<pre><code>void
print_in_binary(const void* data, size_t size) {
    const uint8_t* bytes = as_bytes(data);
    for (size_t i = 0; i &lt; size; i++) {
        print_in_binary(bytes[i]);

        // Для удобства чтения: пробелы между байтами, по 4 байта на строку.
        if ((i + 1) % 4 == 0) {
            cout &lt;&lt; '\n';
        }
        else {
            cout &lt;&lt; ' ';
        }
    }
}
</code></pre>

<p><strong>После выполнения у каждого контролируются результаты.</strong></p>

<p>В двоичной системе <code>0x42</code> будет <code>0b00101010</code>. Этот байт должен стоять первым
при печати целого числа любой длины, а за ним — байты с нулями.</p>

<h2>2. Битовый калькулятор (самостоятельно)</h2>

<p><strong>На этом шаге каждый должен</strong> выполнить пункт 2 задания на ЛР № 4 с сайта,
продемонстрировать корректную работу программы и занести код и результаты
в отчет в виде текста.</p>

<p><strong>Вопрос:</strong> почему 1025 (<code>0b00000100'00000001</code>, <code>0x0401</code>) представлено байтами
<code>01 04</code>, а не наоборот?</p>

<p><strong>Ответ:</strong> потому что на x86 (Intel) порядок байт от младшего к старшему
(little-endian), то есть младший байт в памяти расположен первым.</p>

<h2>3. Считывание файла и разбиение его текста на массив строк (под руководством)</h2>

<p>Решим задачу: считать содержимое текстового файла целиком в память, затем
разбить его на строки, причем пустые строки не учитывать, наконец, освободить
всю выделенную в процессе память.</p>

<p>Укрупненный алгоритм таков:</p>

<ol>
<li>Считать текст из файла в память, выделив для этого участок.</li>
<li>Разбить текст на не пустые строки, выделяя по участку для каждой.</li>
<li>Удалить участок памяти, выделенный под текст, и все участки, выделенные
 под строки.</li>
</ol>

<p>На данном этапе имеет смысл решить, какие ресурсы будет использовать программа
(подо что нужно выделять участки памяти), и какие части программы будут
управлять ими (выделять и освобождать).</p>

<ul>
<li><p>Область памяти под текст файла должна выделяться перед тем, как в нее будут
занесены данные, а освобождаться не раньше, чем текст будет разбит
на строки, то есть уже не в той части, где ведется работа с файлом.</p></li>
<li><p>Под каждую строку нужен отдельный участок памяти, который затем нужно будет
освободить, то есть сохранять указатель на него.  Количество таких
указателей заранее неизвестно, поэтому под них нужен динамический массив —
еще один участок памяти.  Его нужно будет освободить после освобождения
всех участков под строки.</p></li>
</ul>

<p>Чтобы упростить программу, а также для разнообразия, выделим отдельно подсчет
непустых строк и отдельно — деление текста на них.  Тогда можно выделять
массив указателей на строки сразу после их подсчета и передавать указатель
на эту область памяти в функцию, которая разделит текст на строки.</p>

<p>Вот как может выглядеть программа, если изолировать оговоренные части в функции:</p>

<pre><code>auto text = load_file(path);
auto line_count = count_nonempty_lines(text);
auto lines = allocate_lines(line_count);
to_lines(text, lines);
deallocate(text, lines);
</code></pre>

<p>Вместо всех типов использовано <code>auto</code>, но стоит выбрать их прямо сейчас,
чтобы получить прототип программы, который будет хотя бы просто компилироваться.</p>

<ul>
<li><p>Исходными данными для загрузки текста является путь к файлу, результатом -
указатель на загруженные в память символы, изменять ничего не нужно:
<code>const char* load_file(const char* path);</code>.</p></li>
<li><p>Функция подсчета непустых строк принимает текст, который не изменяет,
а возвращает количество: <code>size_t count_nonempty_lines(const char* text);</code>.</p></li>
<li><p>Каждое предложение — это цепочка символов, <code>char*</code>.  Массив предложений —
это область памяти с началами цепочек, то есть массив <code>char*</code>,
то есть <code>char**</code>, который нужно выделить, зная его длину:
<code>char** allocale_lines(size_t line_count);</code>.</p></li>
<li><p>Функция деления текста на строки не изменяет текст, а также принимает
массив указателей, содержимое которого <em>меняет</em>, поэтому <code>const</code> не нужно:
<code>void to_lines(const char* text, char** lines);</code>.</p></li>
<li><p>При освобождении памяти нужно работать с переменными, тип которых нами
уже определен: <code>void deallocate(const char* text, const char* lines);</code>.
Функции этой не нужно изменять содержимое массивов, нужны только их адреса.</p></li>
</ul>

<p><strong>На этом шаге каждый должен</strong> перенести к себе прототип программы и убедиться,
что он компилируется:</p>

<ul>
<li>функцию <code>main()</code>, заменив <code>auto</code> на конкретные типы;</li>
<li>все функции, типы которых рассмотрены, с заглушкой вместо реализации:
делать в теле ничего не нужно, а в функциях, возвращающих указатель,
возвращать <code>nullptr</code>.</li>
</ul>

<h3>3.1. Считывание содержимого текстового файла в память как строки C</h3>

<p>Чтобы считать содержимое файла в память, необходимо:</p>

<ol>
<li>Открыть файл для чтения данных.</li>
<li>Определить размер файла в байтах.</li>
<li>Выделить блок памяти достаточного размера.</li>
<li>Считать содержимое файла в этот блок, чтобы получилась строка C.</li>
<li>Завершить работу с файлом.</li>
<li>По окончании работы с текстом удалить его из памяти.</li>
</ol>

<p>В случае невозможности загрузки будем возвращать нулевой указатель.  Итак,</p>

<pre><code>const char*
load_file(const char* path) {
</code></pre>

<p>В стандартной библиотеке C++ имеется класс <code>ifstream</code> (файл <code>&lt;fstream&gt;</code>)
для чтения файлов.  Путь к файлу передается в конструктор при создании объекта.
Ниже объявляется переменная <code>input</code> класса <code>ifstream</code>, которая соответствует
открытому для чтения файлу по пути <code>path</code>:</p>

<pre><code>    ifstream input(path);
</code></pre>

<p>Объекты <code>ifstream</code> (как и другие потоки) имеет метод <code>bad()</code>, который возвращает
<code>false</code> после ошибок, в том числе при невозможности открыть файл.  Им можно
воспользоваться для проверки:</p>

<pre><code>    if (input.bad()) {
        return nullptr;
    }
</code></pre>

<p>Поток файлового ввода позволяет перемещаться по файлу, то есть продолжить
чтение с произвольной позиции в файле.  Позиция может быть указана с начала
файла, с конца файла или относительно текущей, которая может быть получена.
Тогда определить размер файла можно, переместившись в конец и узнав текущую
позицию:</p>

<pre><code>    input.seekg(ios::end, 0);
    auto size = input.tellg();
</code></pre>

<p>Для дальнейшей работы нужно переместиться обратно в начало файла:</p>

<pre><code>    input.seekg(ios::beg, 0);
</code></pre>

<p>Выделение памяти производится оператором <code>new</code>.  Какой объем памяти необходим
под строки C с текстом файла длиной <code>size</code>?  Строки C, помимо полезных символов,
включают также и завершающий <code>'\0'</code>, значит, нужно <code>(size + 1)</code> элементов:</p>

<pre><code>    char* data = new char[size + 1];
</code></pre>

<p>У <code>ifstream</code> есть метод для считывания заданного количества байт в область
памяти:</p>

<pre><code>    input.read(data, size);
</code></pre>

<p>Завершающий <code>'\0'</code> — это особенность C, в файле этого символа нет, поэтому его
нужно записать в массив самостоятельно:</p>

<pre><code>    data[size] = 0;
</code></pre>

<p>Работа с файлом закончена.  Можно закрыть его методом <code>close()</code> в <code>ifstream</code>,
но нет необходимости: он будет вызван в деструкторе объекта <code>input</code>, поэтому
можно просто завершить функцию:</p>

<pre><code>    return data;
}
</code></pre>

<p><strong>Самопроверка:</strong> записать полностью функцию <code>load_file()</code> и проверить
её работу, напечатав текст после его считывания.  Путь к файлу можно вводить
и через <code>std::string</code>, чтобы преобразовать её к <code>const char*</code>, нужен метод
<code>c_str()</code>.</p>

<h3>3.2. Разбиение текста на массив (не пустых) строк</h3>

<h4>3.2.1. Подсчет количества строк</h4>

<p>В начале файла могут быть пустые строки, очевидно, их нужно пропустить, то есть,
взяв указатель на начало текста, получить другой указатель — на начало первой
не пустой строки.  Пустые строки — это непрерывная последовательность символов
<code>'\n'</code>. Если таких строк нет, пусть это будет указатель на конец текста,
то есть на его завершающий <code>'\0'</code>.  Далее необходимо найти конец строки,
то есть указатель на первый встреченный в ней символ <code>'\n'</code>.  Если после этого
пропустить все пустые строки, мы вернемся к тому же состоянию, что и перед
началом очередной строки, то есть выделение не пустой строки можно выполнять
циклически.  Итого, алгоритм:</p>

<ol>
<li>Пропустить пустые строки (найти указатель на начало первой не пустой).</li>
<li>Если достигнут конец теста, прекратить подсчет.</li>
<li>Увеличить счетчик строк на 1 (изначально он был 0).</li>
<li>Найти конец строки (указатель на это место).</li>
<li>Пропустить пустые строки, начиная с найденного конца строки.</li>
<li>Перейти к пункту 2.</li>
</ol>

<p>Если считать, что уже реализована функция пропуска пустых строк
<code>const char* skip_empty_lines(const char* text)</code> и функция поиска конца строки
<code>const char* find_line_end(const char* text)</code>, реализация может быть такой:</p>

<pre><code>size_t
count_nonempty_lines(const char* text) {
    size_t count = 0;
    const char* line_start = skip_empty_lines(text);
    while (*line_start != '\0') {
        count++;
        const char* line_end = find_line_end(line_start);
        line_start = skip_empty_lines(line_end);
    }
    return count;
}
</code></pre>

<p>Для поиска конца строки нужно проверять символ за символом, пока очередной
не окажется <code>'\n'</code> или завершающим <code>'\0'</code>.  В любом случае нужно вернуть
адрес того символа, до которого дошел поиск:</p>

<pre><code>const char*
find_line_end(const char* text) {
    size_t i = 0;
    while (text[i] != '\0' &amp;&amp; text[i] != '\n') {
        i++;
    }
    return &amp;text[i];
}
</code></pre>

<p>Пропуск пустых строк, то есть подряд идущих символов <code>'\n'</code>, тривиален:</p>

<pre><code>const char*
skip_empty_lines(const char* text) {
    size_t i = 0;
    while (text[i] == '\n') {
        i++;
    }
    return &amp;text[i];
}
</code></pre>

<p>Отдельной проверки на окончание строки не требуется, потому что <code>'\0' != '\n'</code>,
и цикл прервется автоматически.</p>

<h4>3.2.2. Выделение памяти под массив строк</h4>

<p>Выделение памяти делается оператором <code>new</code>.  Функция <code>allocate_lines()</code> носит
практически декоративный характер:</p>

<pre><code>char**
allocate_lines(size_t line_count) {
    return new char* [line_count];
}
</code></pre>

<p>Результат — адрес области памяти с указателями, то есть еще потребуется
выделять блоки под сами строки, указатели на которые и будут сохраняться
в динамическом массиве.</p>

<h4>3.2.3. Разбиение текста на предложения</h4>

<p>Разделение текста на предложения похоже на их подсчет, но вместо простого
увеличения счетчика нужно выделять память под предложение и копировать в нее
часть текста.</p>

<pre><code>void
to_lines(const char* text, char** lines) {
    size_t count = 0;
    const char* line_start = skip_empty_lines(text);
    while (*line_start != '\0') {
        const char* line_end = find_line_end(line_start);

        const size_t line_length = line_end - line_start;
        lines[count] = new char[line_length + 1];
        strncpy(lines[count], line_start, line_length);

        count++;

        line_start = skip_empty_lines(line_end);
    }
    return count;
}
</code></pre>

<h4>3.3. Освобождение памяти</h4>

<p>Необходимо освободить в функции <code>deallocate()</code>:</p>

<ol>
<li><p>Текст, загруженный из файла:</p>

<p><code>delete[] text;</code></p></li>
<li><p>Каждую из строк, скопированных из текста.</p>

<p><code>
 for (size_t i = 0; i &lt; line_count; i++) {
    delete[] lines[i];
 }
</code></p></li>
<li><p>Массив указателей на строки (уже освобожденные):</p>

<p><code>delete[] lines;</code></p></li>
</ol>

<p>Необходимое значение <code>line_count</code> нужно добавить в параметры функции
и передавать из <code>main()</code>; также вместо <code>deallocate()</code> вписать её код
в конец <code>main()</code>.</p>

<p><strong>На этом шаге каждый должен</strong> завершить программу и проверить её работу,
добавив после разбиения текста на строки их печать:</p>

<pre><code>for (size_t i = 0; i &lt; line_count; i++) {
    cout &lt;&lt; lines[i] &lt;&lt; '\n';
}
</code></pre>

<h2>4. Разбиение теста на предложения, подсчет слов в них (самостоятельно)</h2>

<p>Необходимо разбивать текст не на строки, а на предложения — участки текста,
ограниченные <code>'.'</code>, <code>'!'</code> или <code>'?'</code> (возможно, подряд: <code>"..."</code>, <code>"?!"</code>).
Затем необходимо подсчитать количество слов в каждом предложении;
слова разделяются одним или несколькими пробелами или запятыми.
Например, вот два предложения, из шести и трех слов:</p>

<pre><code>News,from beyond the Narrow Sea.  Haven't you heard?!
    ↑                           ↑↑
нет пробела                 два пробела
</code></pre>

<p>Наконец, требуется напечатать предложения в порядке убывания количества слов.
В конце программы все выделенная память должна освобождаться через <code>delete[]</code>.</p>

<p>По сути, нужно обобщить уже реализованные функции, чтобы они могли делить текст
не только по символу конца строки, а по любому символу из набора (который можно
представить как строку C):</p>

<pre><code>const char* find_any(const char* text, const char* what_to_find);
const char* skip_any(const char* text, const char* what_to_skip);
</code></pre>

<p>На самом деле, похожие функции уже есть в стандартной библиотеке:
<code>strpbrk()</code> и <code>strspn()</code> из <code>&lt;cstring&gt;</code>.  Можно воспользоваться ими.</p>

<p>Функция для подсчета частей текста (ранее строк, теперь — между разделителями)
понадобится и чтобы выделить предложения, и чтобы подсчитать слова в них:</p>

<pre><code>size_t count_parts(const char* text, const char* delimiters);
</code></pre>

<p>Функция деления текста останется почти неизменной, только добавится параметр
для указания разделителей:</p>

<pre><code>void split(const char* text, const char* delimiters, char** parts);
</code></pre>

<p><strong>Каждый должен</strong> продемонстрировать код и работу итоговой программы
и занести это в отчет в виде текста.</p>

<hr />

<p>При наличии времени имеет смысл пройтись по вопросам защиты ЛР № 4, по крайней
мере, кто не будет знать, что делать, может заняться этим.</p>

    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2016&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="../../assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="../../assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
