<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <link rel="stylesheet" type="text/css" href="../assets/styles/style.css"/>
  <title>К ЛР № 4 по РПОСУ´17| Кафедра управления и информатики</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="методическое-пособие-к-лр-4-представление-данных-в-памяти-по-рпосу17">Методическое пособие к ЛР № 4 «Представление данных в памяти» по РПОСУ´17</h1>
<h2 id="функции-print_in_">1. Функции <code>print_in_*()</code></h2>
<p>Разобьем задачу на более простые части.</p>
<p>Начнем с <code>print_in_hex()</code>. Байт — это 8 бит, то есть две цифры в шестнадцатеричной системе. Чтобы напечатать байт, нужно напечатать цифру, соответствующую его старшей и младшей половине (они называются nibble). Любой блок данных (по адресу в нетипизированном указателе <code>void*</code>) — это массив байт; нужно только указать компилятору рассмотреть <code>void*</code> как <code>uint8_t*</code>. Очевидно, чтобы напечатать массив байт, нужно напечатать каждый байт в цикле.</p>
<p>Перевод байта в двоичную запись можно делать целиком, дробить байт нет смысла. Печать массива байт в двоичном виде по сути не отличается от печати их в шестнадцатеричной системе счисления.</p>
<p>Итак, элементарные задачи:</p>
<ol style="list-style-type: decimal">
<li>Напечатать шестнадцатеричную цифру для значения от 0 до 15.</li>
<li>Извлечь из байта младший nibble как число от 0 до 15.</li>
<li>Извлечь из байта старший nibble как число от 0 до 15.</li>
<li>Напечатать байт в шестнадцатеричном виде как два nibble.</li>
<li>Преобразовать <code>void*</code> в <code>uint8_t*</code>.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (hex).</li>
<li>Напечатать байт в двоичном виде.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (binary).</li>
</ol>
<h3 id="напечатать-шестнадцатеричную-цифру-для-значения-от-0-до-15">1.1. Напечатать шестнадцатеричную цифру для значения от 0 до 15</h3>
<p>Напишем вспомогательную функцию, которая будет представлять значение от 0 до 15 в шестнадцатеричном виде. Что она принимает? Целое число от 0 до 15, для этого достаточно <code>uint8_t</code>. Что она возвращает? Можно сразу печатать результат, тогда не нужно возвращать ничего (<code>void</code>). Но вспомним, что функции желательно делать максимально пригодными для повторного использования, и вовсе не всегда нужно печатать nibble не экране. Поэтому лучше возвращать символ для nibble, то есть <code>char</code>. Итого: <code>char nibble_to_hex(uint8_t i);</code>.</p>
<p>Как реализовать <code>nibble_to_hex()</code>? Очевидный вариант — через <code>switch</code> на 16 вариантов. Есть и более лаконичный вариант: заведем массив цифр <code>char digits[] = &quot;0123456789abcdef&quot;;</code> и будем для значения <code>i</code> возвращать <code>digits[i]</code>. На практике популярен еще один вариант - через коды символов. Вспомним, что символы в памяти хранятся как их коды, например, коды цифр от <code>'0'</code> до <code>'9'</code> — от 48 до 57, а коды букв от <code>'a'</code> до <code>'f'</code> — от 97 до 102. Таким образом, если <code>i</code> меньше 10, можно прибавить <code>i</code> к <code>'0'</code> и получить соответствующую цифру; если <code>i</code> больше, нужно прибавить к <code>'a'</code> столько, на сколько <code>i</code> больше 10 (то есть для 10 — 0, для 11 — 1 и т. д.).</p>
<p>Важный момент — самопроверка. Чтобы проверить работу <code>nibble_to_hex()</code>, добавим в программу функцию-тест, вызываемую в начале <code>main()</code>, из 16 строк:</p>
<pre><code>assert(nibble_to_hex(0x0) == &#39;0&#39;);
assert(nibble_to_hex(0x1) == &#39;1&#39;);
// ...
assert(nibble_to_hex(0xf) == &#39;f&#39;);</code></pre>
<p>Еще один вопрос — реакция <code>nibble_to_hex()</code> на некорректные значения аргумента. Можно решить его путем защитного программирования: добавить в начало функции</p>
<pre><code>assert(0x0 &lt;= i &amp;&amp; i &lt;= 0xf);</code></pre>
<h3 id="извлечь-из-байта-младший-nibble-как-число-от-0-до-15">1.2. Извлечь из байта младший nibble как число от 0 до 15</h3>
<p>Задача сводится к тому, чтобы из восьми бит четыре младших оставить такими, как есть, а четыре старших обнулить. Типовое решение — наложить битовую маску. Битовая маска следующая: <code>0b00001111</code>, или <code>0x0f</code>, — в ней единицы стоят в тех позициях, биты в которых нужно извлечь. Логическое «И» (<code>&amp;</code>) бита <code>x</code> с нулем дает 0, а с единицей - <code>x</code>, то есть <code>byte &amp; mask</code> даст искомый младший nibble. Решение для математиков — взять остаток от деления байта на 32 (<code>0b00010000</code>).</p>
<h3 id="извлечь-из-байта-старший-nibble-как-число-от-0-до-15">1.3. Извлечь из байта старший nibble как число от 0 до 15</h3>
<p>Можно разбить эту задачу еще на две: выделение старших разрядов байта и их перемещение (сдвиг) на позиции младших разрядов. Какая маска подойдет для выделения? Очевидно, <code>0b11110000</code> (<code>0xf0</code>). Сдвиг вправо на 4 разряда делается оператором <code>&gt;&gt;</code>: <code>byte &gt;&gt; 4</code>. По стандарту C++, старшие биты результата будут равны 0, поэтому на самом деле выделять старшие биты не нужно. Сдвиг вправо на 4 позиции математически равносилен делению на 2⁴, но при работе с битами сдвиг лучше выражает суть дела.</p>
<h3 id="напечатать-байт-как-два-nibble">1.4. Напечатать байт как два nibble</h3>
<p>Запишем в коде все предыдущие рассуждения:</p>
<pre><code>void
print_in_hex(uint8_t byte) {
    cout &lt;&lt; nibble_to_hex(byte &gt;&gt; 4)
         &lt;&lt; nibble_to_hex(byte &amp; 0xf);
}</code></pre>
<p>Для самопроверки следует попробовать напечатать байты <code>0x0</code>, <code>0xab</code>, <code>0xff</code>.</p>
<h3 id="преобразовать-void-в-uint8_t-и-напечатать-массив-этих-байт">1.5, 1.6. Преобразовать <code>void*</code> в <code>uint8_t*</code> и напечатать массив этих байт</h3>
<p>Заключим преобразование типов в функцию. В реальной программе это было бы излишне, но функция — это ведь еще и помощь программисту в структурировании программы, и раз так удобнее рассуждать, то и сделаем.</p>
<pre><code>const uint8_t* as_bytes(const void* data);</code></pre>
<p>Здесь важны ключевые слова <code>const</code>. Они означают, что данные по адресу, хранимому в указателе, не могут быть изменены через этот указатель.</p>
<p>Считая, что она реализована, можно записать печать массива сразу:</p>
<pre><code>void
print_in_hex(const void* data, size_t size) {
    const uint8_t* bytes = as_bytes(data);
    for (size_t i = 0; i &lt; size; i++) {
        print_in_hex(bytes[i]);

        // Для удобства чтения: пробелы между байтам, по 16 байт на строку.
        if ((i + 1) % 16 == 0) {
            cout &lt;&lt; &#39;\n&#39;;
        }
        else {
            cout &lt;&lt; &#39; &#39;;
        }
    }
}</code></pre>
<p>Указание компилятору, что значение одного типа нужно трактовать как значение другого, называется приведением типов. Из лекций известно, что в данном случае корректна такая реализация:</p>
<pre><code>const uint8_t*
as_bytes(const void* data) {
    return reinterpret_cast&lt;const uint8_t*&gt;(data);
}</code></pre>
<p><strong>Самопроверка:</strong> завести переменные типа <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> и дать им одно и то же значение, <code>0x42</code>. Напечатать их через новую функцию и убедиться визуально, что единственным ненулевым байтом будет <code>0x42</code> в каждом случае, а всего байт будет столько, сколько ожидается. Вторым параметром следует передавать <code>sizeof</code>, например:</p>
<pre><code>uint32_t u32 = 0x42;
cout &lt;&lt; &quot;u32 bytes: &quot;;
print_in_hex(&amp;u32, sizeof(u32));
cout &lt;&lt; &#39;\n&#39;;</code></pre>
<h3 id="напечатать-байт-в-двоичном-виде">1.7. Напечатать байт в двоичном виде</h3>
<p>Известен способ перевода в двоичную систему путем взятия остатков от деления на два, однако, порядок остатком получается обратным порядку бит. В программе проще проверять биты, начиная со старшего, и печатать <code>0</code>, если бит равен 0, и <code>1</code>, если бит равен 1. Для выделения бита можно воспользоваться маской: старший бит выделяется как <code>0b10000000</code>, или <code>(0x1 &lt;&lt; 7)</code>, младший — маской <code>(0x1 &lt;&lt; 0)</code>. После наложения маски с одним установленным битом в результате останется либо 0 (если соответствующий бит не установлен), либо не-ноль, если установлен. Выделим эту логику в функцию по аналогии с <code>nibble_to_hex()</code>:</p>
<pre><code>char
bit_digit(uint8_t byte, uint8_t bit) {
    if (byte &amp; (0x1 &lt;&lt; bit)) {
        return &#39;1&#39;;
    }
    return &#39;0&#39;;
}</code></pre>
<p>Сдвиги на 7, 6, ..., 0 бит логично делать циклом. Итого:</p>
<pre><code>void
print_in_binary(uint8_t byte) {
    for (uint8_t bit = 7; bit &gt; 0; bit--) {
        cout &lt;&lt; bit_digit(byte, shift);
    }
}</code></pre>
<p><strong>Самопроверка:</strong> перевести в двоичное представление и напечатать числа из лекционного слайда про двоичные операции (исходные два числа и результаты всех действий).</p>
<h3 id="напечатать-блок-данных-в-двоичном-виде">1.8. Напечатать блок данных в двоичном виде</h3>
<p>Очевидно, что приведение типов не отличается от случая для шестнадцатеричной системы. Напишем и проверим по аналогии с <code>print_in_hex()</code>:</p>
<pre><code>void
print_in_binary(const void* data, size_t size) {
    const uint8_t* bytes = as_bytes(data);
    for (size_t i = 0; i &lt; size; i++) {
        print_in_binary(bytes[i]);

        // Для удобства чтения: пробелы между байтами, по 4 байта на строку.
        if ((i + 1) % 4 == 0) {
            cout &lt;&lt; &#39;\n&#39;;
        }
        else {
            cout &lt;&lt; &#39; &#39;;
        }
    }
}</code></pre>
<p>В двоичной системе <code>0x42</code> будет <code>0b00101010</code>. Этот байт должен стоять первым при печати целого числа любой длины, а за ним — байты с нулями.</p>
<h2 id="битовый-калькулятор">2. Битовый калькулятор</h2>
<p>В отчет нужно занести код и результаты в отчет в виде текста.</p>
<p><strong>Вопрос:</strong> почему 1025 (<code>0b00000100'00000001</code>, <code>0x0401</code>) представлено байтами <code>01 04</code>, а не наоборот?</p>
<p><strong>Ответ:</strong> потому что на x86 (Intel) порядок байт от младшего к старшему (little-endian), то есть младший байт в памяти расположен первым.</p>
<h2 id="исследование-представления-и-размещения-данных-в-памяти">3. Исследование представления и размещения данных в памяти</h2>
<p>Комментарий к отчету по данному пункту ЛР.</p>
<ul>
<li><p>Необходим вывод программы — все, что нужно напечатать по заданию.</p></li>
<li><p>В распечатанном массиве байт, которые занимает массив структур, нужно отметить, какие байты чему соответствуют (элементам массива, полям структуры).</p></li>
<li><p>Необходима готовность отвечать (пользуясь отчетом), что представляет собой тот или иной участок распечатанного блока памяти, и почему его содержимое именно таково (кроме действительных чисел).</p></li>
</ul>
<h2 id="работа-со-строками-c">4. Работа со строками C</h2>
<p>Вместо пошагового выполнения ЛР рассмотрим решение двух типовых задач: ввода и обработки строки C функциями стандартной библиотеки и загрузки текста из файла в строку C. Задание на ЛР представляет собой их комбинацию.</p>
<h3 id="ввод-строки-c-и-её-обработка-функциями-стандартной-библиотеки">4.1. Ввод строки C и её обработка функциями стандартной библиотеки</h3>
<p>Решим задачу: считать строку C и напечатать по отдельности слов в ней (слова разделены пробелами и знаками препинания).</p>
<h4 id="ввод-строки-c">Ввод строки C</h4>
<p>Для определенности предположим, что длина строки не превышает некоторой заранее заданной, например, 255 символов. С учетом завершающего <code>'\0'</code> под строку нужно 256 символов:</p>
<pre><code>const size_t MAX_SIZE = 256;
char text[MAX_SIZE];</code></pre>
<p>Ввести с строку C можно функцией <a href="http://en.cppreference.com/w/cpp/io/c/fgets"><code>fgets()</code></a>. Ознакомимся с документацией по ссылке. В документации обычно есть и примеры использования описываемых функций.</p>
<p>Прототип функции:</p>
<pre><code>char* fgets(char* str, int count, std::FILE* stream);</code></pre>
<p>Над прототипом написано: <code>Defined in header &lt;cstdio&gt;</code> — это значит, что для использования функции нужно включить заголовочный файл <code>&lt;cstdio&gt;</code>.</p>
<p>Под прототипом написано, что делает данная функция: считывает не более <code>count - 1</code> символов и записывает их в массив, на который указывает <code>str</code>; чтение ведется из файлового потока <code>stream</code>.</p>
<p>Нам необходимо считывать строку со стандартного ввода, где взять файловый поток для него? В справочнике <code>std::FILE</code> является ссылкой на статью «C-style file input/output» («Файловый ввод-вывод средствами C»). В конце её в разделе <em>Macros</em> можно найти запись:</p>
<pre><code>stdin       expression of type FILE* associated with the input stream</code></pre>
<p>То есть глобальная переменная <code>stdin</code> из <code>&lt;cstdio&gt;</code> и есть нужный поток (это упоминалось в лекциях).</p>
<p>Итак, вызов для чтения строки:</p>
<pre><code>fgets(text, MAX_SIZE, stdin);</code></pre>
<p>Заметим, что на практике, а не в учебных целях, удобнее считывать строки C++:</p>
<pre><code>string text;
getline(cin, text);</code></pre>
<p>Если затем нужен указатель на массив считанных символов, его можно получить как <code>text.c_str()</code> (менять символы с этом массиве нельзя; при необходимости есть метод <code>text.data()</code>).</p>
<h4 id="разбиение-строки-на-слова">Разбиение строки на слова</h4>
<p>Чтобы напечатать слова строки по отдельности, нужно искать границы слов и печатать часть строки от начала до конца слова. Чтобы найти конец слова, нужно найти первый (от любой позиции внутри слова, в том числе от его начала) символ-разделитель. Разделители могут идти подряд. Вот пример текста:</p>
<pre><code>News,from beyond the Narrow Sea.  Haven&#39;t you heard?!
    ↑                           ↑↑
нет пробела                 два пробела</code></pre>
<p>Кроме знаков препинания, разделители включают также пробел и символы перевода строк:</p>
<pre><code>const char* separators = &quot; \r\n,.!?:;()-&quot;;</code></pre>
<p>Функции стандартной библиотеки для работы со строками C — в заголовочном файле <a href="http://en.cppreference.com/w/cpp/header/cstring"><code>&lt;cstring&gt;</code></a>. Из обширного списка наиболее подходящими для задачи выглядят описания:</p>
<ul>
<li><p><code>strspn()</code> — определяет, сколько первых символов строки подряд относятся к множеству, заданному другой строкой;</p></li>
<li><p><code>strсspn()</code> — определяет, сколько первых символов строки подряд <strong>не</strong> относятся к множеству, заданному другой строкой (например, сколько символов с начала строки — не разделители слов);</p></li>
</ul>
<p>Алгоритм решения:</p>
<ol style="list-style-type: decimal">
<li><p>Определить, сколько разделителей находятся в начале строки — <code>strspn()</code>.</p></li>
<li><p>Пропустить их (сместить указатель на начало строки).</p></li>
<li><p>Если достигнут конец строки (начальный символ — <code>'\0'</code>), закончить работу.</p></li>
<li><p>Найти первый разделитель от нового начала строки (или слова), то есть длину слова — <code>strcspn()</code>.</p></li>
<li><p>Напечатать часть строки от начала слова до разделителя (это можно сделать методом <a href="http://en.cppreference.com/w/cpp/io/basic_ostream/write"><code>cout.write()</code></a> или функцией <code>fwrite()</code>). Также напечатать символ перевода строки.</p></li>
<li><p>Сдвинуть начало строки вперед на длину слова.</p></li>
<li><p>Перейти к пункту 1.</p></li>
</ol>
<p>Почти каждый шаг алгоритма — всего одна строка или конструкция. Начало строки (то есть еще не разобранной части) будем хранить в переменной:</p>
<pre><code>const char* start = text;</code></pre>
<p>Алгоритм представляет собой цикл:</p>
<pre><code>while (true) {</code></pre>
<ol style="list-style-type: decimal">
<li><p>Определить, сколько разделителей находятся в начале строки:</p>
<pre><code>const size_t separator_count = strspn(start, separators);</code></pre></li>
<li><p>Пропустить их:</p>
<pre><code>start += separator_count;</code></pre></li>
<li><p>Если достигнут конец строки, закончить работу.</p>
<pre><code>if (start[0] == &#39;\0&#39;) {
    break;
}</code></pre></li>
<li><p>Найти первый разделитель от нового начала строки:</p>
<pre><code>const size_t word_length = strcspn(start, separators);</code></pre></li>
<li><p>Напечатать часть строки от начала слова до разделителя:</p>
<pre><code>cout.write(start, word_length);</code></pre></li>
</ol>
<p>Также напечатать символ перевода строки:</p>
<pre><code>      cout &lt;&lt; &#39;\n&#39;;</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><p>Сдвинуть начало строки вперед на длину слова:</p>
<pre><code>start += word_length;</code></pre></li>
</ol>
<p><code>}</code></p>
<p>Соединив участки кода в полноценную программу, можно убедиться, что она работает правильно:</p>
<pre><code>echo &quot;News,from beyond the Narrow Sea.  Haven&#39;t you heard?&quot; | lab04.exe</code></pre>
<p>Вывод:</p>
<pre><code>News
from
beyond
the
Narrow
Sea
Haven&#39;t
you
heard</code></pre>

    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2017&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="../../assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="../../assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
