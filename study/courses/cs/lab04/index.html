<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>РПОСУ. ЛР № 4. Представление данных в памяти</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div>
    <a href="http://uii.mpei.ru">Сайт кафедры</a> →
    <a href="/study/courses">Дисциплины ИТ</a> →
    <a href="/study/courses/cs">РПОСУ</a>
</div>
<header id="title-block-header">
<h1 class="title">РПОСУ. ЛР № 4. Представление данных в памяти</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#цель-работы">Цель работы</a></li>
<li><a href="#задание">Задание</a><ul>
<li><a href="#подготовить-инструменты-для-исследований-и-отладки">1. Подготовить инструменты для исследований и отладки</a></li>
<li><a href="#написать-программу-калькулятор-для-побитовых-операций">2. Написать программу-калькулятор для побитовых операций</a></li>
<li><a href="#изучить-представление-и-размещение-данных-в-памяти">3. Изучить представление и размещение данных в памяти</a></li>
<li><a href="#написать-программу-для-обработки-текстового-файла">4. Написать программу для обработки текстового файла</a></li>
</ul></li>
<li><a href="#указания-к-выполнению">Указания к выполнению</a><ul>
<li><a href="#функции-print_in_">1. Функции <code>print_in_*()</code></a><ul>
<li><a href="#напечатать-шестнадцатеричную-цифру-для-значения-от-0-до-15">1.1. Напечатать шестнадцатеричную цифру для значения от 0 до 15</a></li>
<li><a href="#извлечь-из-байта-младший-nibble-как-число-от-0-до-15">1.2. Извлечь из байта младший nibble как число от 0 до 15</a></li>
<li><a href="#извлечь-из-байта-старший-nibble-как-число-от-0-до-15">1.3. Извлечь из байта старший nibble как число от 0 до 15</a></li>
<li><a href="#напечатать-байт-как-два-nibble">1.4. Напечатать байт как два nibble</a></li>
<li><a href="#преобразовать-void-в-uint8_t-и-напечатать-массив-этих-байт">1.5, 1.6. Преобразовать <code>void*</code> в <code>uint8_t*</code> и напечатать массив этих байт</a></li>
<li><a href="#напечатать-байт-в-двоичном-виде">1.7. Напечатать байт в двоичном виде</a></li>
<li><a href="#напечатать-блок-данных-в-двоичном-виде">1.8. Напечатать блок данных в двоичном виде</a></li>
</ul></li>
<li><a href="#битовый-калькулятор">2. Битовый калькулятор</a></li>
<li><a href="#исследование-представления-и-размещения-данных-в-памяти">3. Исследование представления и размещения данных в памяти</a></li>
<li><a href="#работа-со-строками-c">4. Работа со строками C</a><ul>
<li><a href="#ввод-строки-c-и-её-обработка-функциями-стандартной-библиотеки">4.1. Ввод строки C и её обработка функциями стандартной библиотеки</a></li>
</ul></li>
</ul></li>
<li><a href="#контрольные-вопросы">Контрольные вопросы</a></li>
</ul>
</nav>
<h1 id="цель-работы">Цель работы</h1>
<ol type="1">
<li>Знать представление различных типов и структур данных в памяти.</li>
<li>Уметь использовать средства языка и стандартной библиотеки C++ для манипуляций с битами данных, адресами памяти и строками C.</li>
</ol>
<h1 id="задание">Задание</h1>
<p><em>Настоятельно рекомендуется после выполнения каждого пункта данной работы делать коммиты.</em></p>
<h2 id="подготовить-инструменты-для-исследований-и-отладки">1. Подготовить инструменты для исследований и отладки</h2>
<p>Написать функции для печати отдельных байт и блока данных <code>data</code> размером <code>size</code> байтов в шестнадцатеричном и в двоичном представлении:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">void</span> print_in_hex(<span class="dt">uint8_t</span> byte);</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dt">void</span> print_in_hex(<span class="at">const</span> <span class="dt">void</span>* data, <span class="dt">size_t</span> size);</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dt">void</span> print_in_binary(<span class="dt">uint8_t</span> byte);</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">void</span> print_in_binary(<span class="at">const</span> <span class="dt">void</span>* data, <span class="dt">size_t</span> size);</a></code></pre></div>
<p>Для удобства чтения рекомендуется между байтами добавлять пробелы и делать перевод строки, например, после каждых 16-и байт (в <code>print_in_hex()</code>) или после каждых четырех байт (в <code>print_in_binary()</code>).</p>
<h2 id="написать-программу-калькулятор-для-побитовых-операций">2. Написать программу-калькулятор для побитовых операций</h2>
<p>Пользователь вводит первый операнд, затем оператор (символ <code>&amp;</code>, <code>|</code> или <code>^</code>), затем второй операнд. Программа выполняет указанное действие над операндами и печатает результат в шестнадцатеричном и двоичном виде. Операнды — двухбайтовые беззнаковые целые числа (<code>uint16_t</code>).</p>
<p><strong>Пример работы:</strong></p>
<p><strong>Ввод:</strong> <code>1025 &amp; 127</code></p>
<p><strong>Вывод на экран: </strong> <code>01 04 &amp; 7F 00 = 01 00</code></p>
<p><code>00000001 00000100 &amp; 01111111 00000000 = 00000001 00000000</code></p>
<h2 id="изучить-представление-и-размещение-данных-в-памяти">3. Изучить представление и размещение данных в памяти</h2>
<ol type="1">
<li><p>Определить структуру <code>Student</code>, описывающую студента атрибутами:</p>
<ol type="1">
<li>Имя (массив из 17 символов, включая завершающий <code>'\0'</code>).</li>
<li>Год поступления (беззнаковое целое, 2 байта).</li>
<li>Средний балл (с плавающей запятой).</li>
<li>Пол, представленный одним битом (0 — женский, 1 — мужской).</li>
<li>Количество пройденных курсов.</li>
<li>Указатель на структуру <code>Student</code>, описывающую старосту группы (для старосты — нулевой указатель).</li>
</ol>
<p><em>Указание.</em> Поле пола из одного бита можно определить так:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">uint8_t</span> gender : <span class="dv">1</span>;</a></code></pre></div></li>
<li><p>Объявить и заполнить массив из трех структур <code>Student</code>, описывающий двух студентов одной группы и их старосту.</p></li>
<li><p>Напечатать, занести в отчет и письменно пояснить:</p>
<ul>
<li>адрес и размер массива;</li>
<li>адреса и размеры всех элементов массива;</li>
<li>для всех полей одного из элементов массива (не старосты), кроме пола (у битовых полей нет адреса):
<ul>
<li>адрес,</li>
<li>смещение от начала структуры,</li>
<li>размер,</li>
<li>шестнадцатеричное и двоичное представление;</li>
</ul></li>
<li>все элементы массива в шестнадцатеричном виде с указанием соответствия блоков байт полям структур.</li>
</ul>
<p><em>Указание.</em> Смещение поля <code>field</code> структуры типа <code>type</code> от начала любого её экземпляра можно определить макросом <code>offsetof(type, field)</code>.</p></li>
</ol>
<h2 id="написать-программу-для-обработки-текстового-файла">4. Написать программу для обработки текстового файла</h2>
<p><em>Данная часть лабораторной работы выполняется отдельно от предыдущей части, в новом проекте.</em></p>
<p>В учебных целях текст нужно представлять только строками C, размещаемыми в динамической памяти или на стеке.</p>
<ol type="1">
<li><p>Запросить у пользователя имя файла, сохранив его в массиве символов, размещенном на стеке (не в динамической памяти).</p></li>
<li><p>Проверить, используя функции стандартной библиотеки C++ для работы со строками C, что введенное имя файла корректно (в Windows):</p>
<ul>
<li>не содержит запрещенных символов: <code>*</code>, <code>"</code>, <code>&lt;</code>, <code>&gt;</code>, <code>?</code> или <code>|</code>;</li>
<li>если содержит двоеточие, то только вторым символом, которому предшествует буква, и за двоеточием следует обратная косая черта (<code>\</code>).</li>
<li>если файл имеет расширение, то только <code>*.txt</code> (в любом регистре).</li>
</ul>
<p>Указание. Задачи решаются стандартными функциями <code>isalpha()</code>, <code>strchr()</code>, <code>strrchr()</code>, <code>strncmp()</code>, <code>tolower()</code>.</p></li>
<li><p>Если введенное имя файла не имеет расширения, добавить расширение <code>.txt</code>.</p></li>
<li><p>Загрузить содержимое текстового файла в память целиком:</p>
<ol type="1">
<li>Использовать <code>ifstream</code> или <code>fopen()</code> для доступа к файлу.</li>
<li>Использовать методы <code>seekg()</code> и <code>tellg()</code> либо функции <code>fseek()</code> и <code>ftell()</code> для определения размера файла, переместившись в его конец и получив текущее положение в файле;</li>
<li>Выделить в динамической памяти массив достаточного размера;</li>
<li>Загрузить всё содержимое файла в выделенную область памяти методом <code>read()</code> или функцией <code>fread()</code>.</li>
</ol></li>
<li><p>Запросить у пользователя строку, поместив её в массив на стеке.</p></li>
<li><p>Подсчитать и вывести число вхождений введенной строки в текст файла.</p></li>
<li><p>Освободить все выделенные в процессе решения блоки памяти.</p></li>
</ol>
<h1 id="указания-к-выполнению">Указания к выполнению</h1>
<h2 id="функции-print_in_">1. Функции <code>print_in_*()</code></h2>
<p>Разобьем задачу на более простые части.</p>
<p>Начнем с <code>print_in_hex()</code>. Байт — это 8 бит, то есть две цифры в шестнадцатеричной системе. Чтобы напечатать байт, нужно напечатать цифру, соответствующую его старшей и младшей половине (они называются nibble). Любой блок данных (по адресу в нетипизированном указателе <code>void*</code>) — это массив байт; нужно только указать компилятору рассмотреть <code>void*</code> как <code>uint8_t*</code>. Очевидно, чтобы напечатать массив байт, нужно напечатать каждый байт в цикле.</p>
<p>Перевод байта в двоичную запись можно делать целиком, дробить байт нет смысла. Печать массива байт в двоичном виде по сути не отличается от печати их в шестнадцатеричной системе счисления.</p>
<p>Итак, элементарные задачи:</p>
<ol type="1">
<li>Напечатать шестнадцатеричную цифру для значения от 0 до 15.</li>
<li>Извлечь из байта младший nibble как число от 0 до 15.</li>
<li>Извлечь из байта старший nibble как число от 0 до 15.</li>
<li>Напечатать байт в шестнадцатеричном виде как два nibble.</li>
<li>Преобразовать <code>void*</code> в <code>uint8_t*</code>.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (hex).</li>
<li>Напечатать байт в двоичном виде.</li>
<li>Напечатать <code>size</code> элементов массива по адресу в <code>uint8_t*</code> (binary).</li>
</ol>
<h3 id="напечатать-шестнадцатеричную-цифру-для-значения-от-0-до-15">1.1. Напечатать шестнадцатеричную цифру для значения от 0 до 15</h3>
<p>Напишем вспомогательную функцию, которая будет представлять значение от 0 до 15 в шестнадцатеричном виде. Что она принимает? Целое число от 0 до 15, для этого достаточно <code>uint8_t</code>. Что она возвращает? Можно сразу печатать результат, тогда не нужно возвращать ничего (<code>void</code>). Но вспомним, что функции желательно делать максимально пригодными для повторного использования, и вовсе не всегда нужно печатать nibble не экране. Поэтому лучше возвращать символ для nibble, то есть <code>char</code>. Итого: <code>char nibble_to_hex(uint8_t i);</code>.</p>
<p>Как реализовать <code>nibble_to_hex()</code>? Очевидный вариант — через <code>switch</code> на 16 вариантов. Есть и более лаконичный вариант: заведем массив цифр <code>char digits[] = "0123456789abcdef";</code> и будем для значения <code>i</code> возвращать <code>digits[i]</code>. На практике популярен еще один вариант - через коды символов. Вспомним, что символы в памяти хранятся как их коды, например, коды цифр от <code>'0'</code> до <code>'9'</code> — от 48 до 57, а коды букв от <code>'a'</code> до <code>'f'</code> — от 97 до 102. Таким образом, если <code>i</code> меньше 10, можно прибавить <code>i</code> к <code>'0'</code> и получить соответствующую цифру; если <code>i</code> больше, нужно прибавить к <code>'a'</code> столько, на сколько <code>i</code> больше 10 (то есть для 10 — 0, для 11 — 1 и т. д.).</p>
<p>Важный момент — самопроверка. Чтобы проверить работу <code>nibble_to_hex()</code>, добавим в программу функцию-тест, вызываемую в начале <code>main()</code>, из 16 строк:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">assert</span>(nibble_to_hex(<span class="bn">0x0</span>) == <span class="ch">&#39;0&#39;</span>);</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">assert</span>(nibble_to_hex(<span class="bn">0x1</span>) == <span class="ch">&#39;1&#39;</span>);</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">assert</span>(nibble_to_hex(<span class="bn">0xf</span>) == <span class="ch">&#39;f&#39;</span>);</a></code></pre></div>
<p>Еще один вопрос — реакция <code>nibble_to_hex()</code> на некорректные значения аргумента. Можно решить его путем защитного программирования: добавить в начало функции</p>
<pre><code>assert(0x0 &lt;= i &amp;&amp; i &lt;= 0xf);</code></pre>
<h3 id="извлечь-из-байта-младший-nibble-как-число-от-0-до-15">1.2. Извлечь из байта младший nibble как число от 0 до 15</h3>
<p>Задача сводится к тому, чтобы из восьми бит четыре младших оставить такими, как есть, а четыре старших обнулить. Типовое решение — наложить битовую маску. Битовая маска следующая: <code>0b00001111</code>, или <code>0x0f</code>, — в ней единицы стоят в тех позициях, биты в которых нужно извлечь. Логическое «И» (<code>&amp;</code>) бита <code>x</code> с нулем дает 0, а с единицей - <code>x</code>, то есть <code>byte &amp; mask</code> даст искомый младший nibble. Решение для математиков — взять остаток от деления байта на 32 (<code>0b00010000</code>).</p>
<h3 id="извлечь-из-байта-старший-nibble-как-число-от-0-до-15">1.3. Извлечь из байта старший nibble как число от 0 до 15</h3>
<p>Можно разбить эту задачу еще на две: выделение старших разрядов байта и их перемещение (сдвиг) на позиции младших разрядов. Какая маска подойдет для выделения? Очевидно, <code>0b11110000</code> (<code>0xf0</code>). Сдвиг вправо на 4 разряда делается оператором <code>&gt;&gt;</code>: <code>byte &gt;&gt; 4</code>. По стандарту C++, старшие биты результата будут равны 0, поэтому на самом деле выделять старшие биты не нужно. Сдвиг вправо на 4 позиции математически равносилен делению на 2⁴, но при работе с битами сдвиг лучше выражает суть дела.</p>
<h3 id="напечатать-байт-как-два-nibble">1.4. Напечатать байт как два nibble</h3>
<p>Запишем в коде все предыдущие рассуждения:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb5-2" title="2">print_in_hex(<span class="dt">uint8_t</span> byte) {</a>
<a class="sourceLine" id="cb5-3" title="3">    cout &lt;&lt; nibble_to_hex(byte &gt;&gt; <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">         &lt;&lt; nibble_to_hex(byte &amp; <span class="bn">0xf</span>);</a>
<a class="sourceLine" id="cb5-5" title="5">}</a></code></pre></div>
<p>Для самопроверки следует попробовать напечатать байты <code>0x0</code>, <code>0xab</code>, <code>0xff</code>.</p>
<h3 id="преобразовать-void-в-uint8_t-и-напечатать-массив-этих-байт">1.5, 1.6. Преобразовать <code>void*</code> в <code>uint8_t*</code> и напечатать массив этих байт</h3>
<p>Заключим преобразование типов в функцию. В реальной программе это было бы излишне, но функция — это ведь еще и помощь программисту в структурировании программы, и раз так удобнее рассуждать, то так и сделаем.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="at">const</span> <span class="dt">uint8_t</span>* as_bytes(<span class="at">const</span> <span class="dt">void</span>* data);</a></code></pre></div>
<p>Здесь важны ключевые слова <code>const</code>. Они означают, что данные по адресу, хранимому в указателе, не могут быть изменены через этот указатель.</p>
<p>Считая, что она реализована, можно записать печать массива сразу:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb7-2" title="2">print_in_hex(<span class="at">const</span> <span class="dt">void</span>* data, <span class="dt">size_t</span> size) {</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="at">const</span> <span class="dt">uint8_t</span>* bytes = as_bytes(data);</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; size; i++) {</a>
<a class="sourceLine" id="cb7-5" title="5">        print_in_hex(bytes[i]);</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="co">// Для удобства чтения: пробелы между байтам, по 16 байт на строку.</span></a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="cf">if</span> ((i + <span class="dv">1</span>) % <span class="dv">16</span> == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb7-9" title="9">            cout &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a>
<a class="sourceLine" id="cb7-10" title="10">        }</a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb7-12" title="12">            cout &lt;&lt; <span class="ch">&#39; &#39;</span>;</a>
<a class="sourceLine" id="cb7-13" title="13">        }</a>
<a class="sourceLine" id="cb7-14" title="14">    }</a>
<a class="sourceLine" id="cb7-15" title="15">}</a></code></pre></div>
<p>Указание компилятору, что значение одного типа нужно трактовать как значение другого, называется приведением типов. Из лекций известно, что в данном случае корректна такая реализация:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="at">const</span> <span class="dt">uint8_t</span>*</a>
<a class="sourceLine" id="cb8-2" title="2">as_bytes(<span class="at">const</span> <span class="dt">void</span>* data) {</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;<span class="at">const</span> <span class="dt">uint8_t</span>*&gt;(data);</a>
<a class="sourceLine" id="cb8-4" title="4">}</a></code></pre></div>
<p><strong>Самопроверка:</strong> завести переменные типа <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> и дать им одно и то же значение, <code>0x42</code>. Напечатать их через новую функцию и убедиться визуально, что единственным ненулевым байтом будет <code>0x42</code> в каждом случае, а всего байт будет столько, сколько ожидается. Вторым параметром следует передавать <code>sizeof</code>, например:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">uint32_t</span> u32 = <span class="bn">0x42</span>;</a>
<a class="sourceLine" id="cb9-2" title="2">cout &lt;&lt; <span class="st">&quot;u32 bytes: &quot;</span>;</a>
<a class="sourceLine" id="cb9-3" title="3">print_in_hex(&amp;u32, <span class="kw">sizeof</span>(u32));</a>
<a class="sourceLine" id="cb9-4" title="4">cout &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a></code></pre></div>
<h3 id="напечатать-байт-в-двоичном-виде">1.7. Напечатать байт в двоичном виде</h3>
<p>Известен способ перевода в двоичную систему путем взятия остатков от деления на два, однако, порядок остатком получается обратным порядку бит. В программе проще проверять биты, начиная со старшего, и печатать <code>0</code>, если бит равен 0, и <code>1</code>, если бит равен 1. Для выделения бита можно воспользоваться маской: старший бит выделяется как <code>0b10000000</code>, или <code>(0x1 &lt;&lt; 7)</code>, младший — маской <code>(0x1 &lt;&lt; 0)</code>. После наложения маски с одним установленным битом в результате останется либо 0 (если соответствующий бит не установлен), либо не-ноль, если установлен. Выделим эту логику в функцию по аналогии с <code>nibble_to_hex()</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">char</span></a>
<a class="sourceLine" id="cb10-2" title="2">bit_digit(<span class="dt">uint8_t</span> byte, <span class="dt">uint8_t</span> bit) {</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="cf">if</span> (byte &amp; (<span class="bn">0x1</span> &lt;&lt; bit)) {</a>
<a class="sourceLine" id="cb10-4" title="4">        <span class="cf">return</span> <span class="ch">&#39;1&#39;</span>;</a>
<a class="sourceLine" id="cb10-5" title="5">    }</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="cf">return</span> <span class="ch">&#39;0&#39;</span>;</a>
<a class="sourceLine" id="cb10-7" title="7">}</a></code></pre></div>
<p>Сдвиги на 7, 6, …, 0 бит логично делать циклом. Итого:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb11-2" title="2">print_in_binary(<span class="dt">uint8_t</span> byte) {</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="cf">for</span> (<span class="dt">uint8_t</span> bit = <span class="dv">7</span>; bit &gt; <span class="dv">0</span>; bit--) {</a>
<a class="sourceLine" id="cb11-4" title="4">        cout &lt;&lt; bit_digit(byte, bit);</a>
<a class="sourceLine" id="cb11-5" title="5">    }</a>
<a class="sourceLine" id="cb11-6" title="6">}</a></code></pre></div>
<p><strong>Внимание:</strong> в данном цикле имеется ошибка - не выводится бит младшего разряда. Предлается устранить ошибку самостоятельно. <strong>Самопроверка:</strong> напечатать число 15 - ожидаемый вывод: <code>00001111</code>. Перевести в двоичное представление и напечатать числа из лекционного слайда про двоичные операции (исходные два числа и результаты всех действий).</p>
<h3 id="напечатать-блок-данных-в-двоичном-виде">1.8. Напечатать блок данных в двоичном виде</h3>
<p>Очевидно, что приведение типов не отличается от случая для шестнадцатеричной системы. Напишем и проверим по аналогии с <code>print_in_hex()</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb12-2" title="2">print_in_binary(<span class="at">const</span> <span class="dt">void</span>* data, <span class="dt">size_t</span> size) {</a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="at">const</span> <span class="dt">uint8_t</span>* bytes = as_bytes(data);</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; size; i++) {</a>
<a class="sourceLine" id="cb12-5" title="5">        print_in_binary(bytes[i]);</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="co">// Для удобства чтения: пробелы между байтами, по 4 байта на строку.</span></a>
<a class="sourceLine" id="cb12-8" title="8">        <span class="cf">if</span> ((i + <span class="dv">1</span>) % <span class="dv">4</span> == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb12-9" title="9">            cout &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a>
<a class="sourceLine" id="cb12-10" title="10">        }</a>
<a class="sourceLine" id="cb12-11" title="11">        <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb12-12" title="12">            cout &lt;&lt; <span class="ch">&#39; &#39;</span>;</a>
<a class="sourceLine" id="cb12-13" title="13">        }</a>
<a class="sourceLine" id="cb12-14" title="14">    }</a>
<a class="sourceLine" id="cb12-15" title="15">}</a></code></pre></div>
<p>В двоичной системе <code>42</code> будет <code>0b00101010</code>. Этот байт должен стоять первым при печати целого числа любой длины, а за ним — байты с нулями.</p>
<h2 id="битовый-калькулятор">2. Битовый калькулятор</h2>
<p>В отчет нужно занести код и результаты в отчет в виде текста.</p>
<p><strong>Вопрос:</strong> почему 1025 (<code>0b00000100'00000001</code>, <code>0x0401</code>) представлено байтами <code>01 04</code>, а не наоборот?</p>
<p><strong>Ответ:</strong> потому что на x86 (Intel) порядок байт от младшего к старшему (little-endian), то есть младший байт в памяти расположен первым.</p>
<h2 id="исследование-представления-и-размещения-данных-в-памяти">3. Исследование представления и размещения данных в памяти</h2>
<p>Комментарий к отчету по данному пункту ЛР.</p>
<ul>
<li><p>Необходим вывод программы — все, что нужно напечатать по заданию.</p></li>
<li><p>В распечатанном массиве байт, которые занимает массив структур, нужно отметить, какие байты чему соответствуют (элементам массива, полям структуры).</p></li>
<li><p>Необходима готовность отвечать (пользуясь отчетом), что представляет собой тот или иной участок распечатанного блока памяти, и почему его содержимое именно таково (кроме действительных чисел).</p></li>
</ul>
<h2 id="работа-со-строками-c">4. Работа со строками C</h2>
<p>Вместо пошагового выполнения ЛР рассмотрим решение двух типовых задач: ввода и обработки строки C функциями стандартной библиотеки и загрузки текста из файла в строку C. Задание на ЛР представляет собой их комбинацию.</p>
<h3 id="ввод-строки-c-и-её-обработка-функциями-стандартной-библиотеки">4.1. Ввод строки C и её обработка функциями стандартной библиотеки</h3>
<p>Решим задачу: считать строку C и напечатать по отдельности слов в ней (слова разделены пробелами и знаками препинания).</p>
<h4 id="ввод-строки-c">Ввод строки C</h4>
<p>Для определенности предположим, что длина строки не превышает некоторой заранее заданной, например, 255 символов. С учетом завершающего <code>'\0'</code> под строку нужно 256 символов:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="at">const</span> <span class="dt">size_t</span> MAX_SIZE = <span class="dv">256</span>;</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">char</span> text[MAX_SIZE];</a></code></pre></div>
<p>Ввести с строку C можно функцией <a href="http://en.cppreference.com/w/cpp/io/c/fgets"><code>fgets()</code></a>. Ознакомимся с документацией по ссылке. В документации обычно есть и примеры использования описываемых функций.</p>
<p>Прототип функции:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">char</span>* fgets(<span class="dt">char</span>* str, <span class="dt">int</span> count, <span class="dt">FILE</span>* stream);</a></code></pre></div>
<p>Над прототипом написано: <code>Defined in header &lt;cstdio&gt;</code> — это значит, что для использования функции нужно включить заголовочный файл <code>&lt;cstdio&gt;</code>.</p>
<p>Под прототипом написано, что делает данная функция: считывает не более <code>count - 1</code> символов и записывает их в массив, на который указывает <code>str</code>; чтение ведется из файлового потока <code>stream</code>.</p>
<p>Нам необходимо считывать строку со стандартного ввода, где взять файловый поток для него? В справочнике <a href="https://en.cppreference.com/w/cpp/io/c"><code>FILE</code></a> является ссылкой на статью «C-style file input/output» («Файловый ввод-вывод средствами C»). В конце её в разделе <em>Macros</em> можно найти запись:</p>
<pre><code>    stdin       expression of type FILE* associated with the input stream</code></pre>
<p>То есть глобальная переменная <code>stdin</code> из <code>&lt;cstdio&gt;</code> и есть нужный поток (это упоминалось в лекциях).</p>
<p>Итак, вызов для чтения строки:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">fgets(text, MAX_SIZE, stdin);</a></code></pre></div>
<p>Заметим, что на практике, а не в учебных целях, удобнее считывать строки C++:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1">string text;</a>
<a class="sourceLine" id="cb17-2" title="2">getline(cin, text);</a></code></pre></div>
<p>Если затем нужен указатель на массив считанных символов, его можно получить как <code>text.c_str()</code> (менять символы в этом массиве нельзя; при необходимости есть метод <code>text.data()</code>).</p>
<h4 id="разбиение-строки-на-слова">Разбиение строки на слова</h4>
<p>Чтобы напечатать слова строки по отдельности, нужно искать границы слов и печатать часть строки от начала до конца слова. Чтобы найти конец слова, нужно найти первый (от любой позиции внутри слова, в том числе от его начала) символ-разделитель. Разделители могут идти подряд. Вот пример текста:</p>
<pre><code>    News,from beyond the Narrow Sea.  Haven&#39;t you heard?!
        ↑                           ↑↑
    нет пробела               два пробела</code></pre>
<p>Кроме знаков препинания, разделители включают также пробел и символы перевода строк:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="at">const</span> <span class="dt">char</span>* separators = <span class="st">&quot; </span><span class="sc">\r\n</span><span class="st">,.!?:;()-&quot;</span>;</a></code></pre></div>
<p>Функции стандартной библиотеки для работы со строками C — в заголовочном файле <a href="http://en.cppreference.com/w/cpp/header/cstring"><code>&lt;cstring&gt;</code></a>. Из обширного списка наиболее подходящими для задачи выглядят описания:</p>
<ul>
<li><p><code>strspn()</code> — определяет, сколько первых символов строки подряд относятся к множеству, заданному другой строкой;</p></li>
<li><p><code>strсspn()</code> — определяет, сколько первых символов строки подряд <strong>не</strong> относятся к множеству, заданному другой строкой (например, сколько символов с начала строки — не разделители слов);</p></li>
</ul>
<p>Алгоритм решения:</p>
<ol type="1">
<li><p>Определить, сколько разделителей находятся в начале строки — <code>strspn()</code>.</p></li>
<li><p>Пропустить их (сместить указатель на начало строки).</p></li>
<li><p>Если достигнут конец строки (начальный символ — <code>'\0'</code>), закончить работу.</p></li>
<li><p>Найти первый разделитель от нового начала строки (или слова), то есть длину слова — <code>strcspn()</code>.</p></li>
<li><p>Напечатать часть строки от начала слова до разделителя (это можно сделать методом <a href="http://en.cppreference.com/w/cpp/io/basic_ostream/write"><code>cout.write()</code></a> или функцией <code>fwrite()</code>). Также напечатать символ перевода строки.</p></li>
<li><p>Сдвинуть начало строки вперед на длину слова.</p></li>
<li><p>Перейти к пункту 1.</p></li>
</ol>
<p>Почти каждый шаг алгоритма — всего одна строка или конструкция. Начало строки (то есть еще не разобранной части) будем хранить в переменной:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="at">const</span> <span class="dt">char</span>* start = text;</a></code></pre></div>
<p>Алгоритм представляет собой цикл:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="cf">while</span> (<span class="kw">true</span>) {</a></code></pre></div>
<ol type="1">
<li><p>Определить, сколько разделителей находятся в начале строки:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="at">const</span> <span class="dt">size_t</span> separator_count = strspn(start, separators);</a></code></pre></div></li>
<li><p>Пропустить их:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1">start += separator_count;</a></code></pre></div></li>
<li><p>Если достигнут конец строки, закончить работу.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="cf">if</span> (start[<span class="dv">0</span>] == <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>) {</a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb24-3" title="3">}</a></code></pre></div></li>
<li><p>Найти первый разделитель от нового начала строки:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="at">const</span> <span class="dt">size_t</span> word_length = strcspn(start, separators);</a></code></pre></div></li>
<li><p>Напечатать часть строки от начала слова до разделителя:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1">cout.write(start, word_length);</a></code></pre></div>
<p>Также напечатать символ перевода строки:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1">cout &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a></code></pre></div></li>
<li><p>Сдвинуть начало строки вперед на длину слова:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1">start += word_length;</a></code></pre></div></li>
</ol>
<p><code>}</code></p>
<p>Соединив участки кода в полноценную программу, можно убедиться, что она работает правильно, выполнив в командной строке:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb29-1" title="1"><span class="bu">echo</span> <span class="st">&quot;News,from beyond the Narrow Sea.  Haven&#39;t you heard?&quot;</span> <span class="kw">|</span> <span class="ex">lab04.exe</span></a></code></pre></div>
<p>Вывод:</p>
<pre><code>News
from
beyond
the
Narrow
Sea
Haven&#39;t
you
heard</code></pre>
<h1 id="контрольные-вопросы">Контрольные вопросы</h1>
<ol type="1">
<li><p>Опишите назначение и использование операторов <code>new</code> и <code>delete</code>. Чем отличается синтаксис удаления массива от синтаксиса удаления одиночного значения?</p></li>
<li><p>Как при помощи динамических массивов организовать работу с квадратной матрицей, размер которой становится известен во время выполнения?</p></li>
<li><p>Что такое «рваный» массив (jagged array)? Как выделять и освобождать память под его элементы, как к ним обращаться?</p></li>
<li><p>Каковы особенности арифметики типов с плавающей запятой по сравнению с математически точной и сравнения их значений?</p></li>
<li><p>Как и почему корректно сравнивать значения с плавающей запятой и бороться с ошибками округления при операциях над такими значениями?</p></li>
<li><p>В чем заключается арифметика с фиксированной запятой, какие у нее преимущества и недостатки по сравнению с арифметикой типов с плавающей запятой?</p></li>
<li><p>Опишите действие оператора <code>reinterpret_cast</code>. В каких случаях его удобно применять, и какие проблемы при этом могут возникнуть?</p></li>
<li><p>Что такое выравнивание данных (alignment)? Почему оно существует, зачем и как контролировать его наличие?</p></li>
<li><p>Как определить размер переменной в C++, и в каких случаях он отличается от размера полезных данных, связанных с переменной?</p></li>
<li><p>Какие побитовые операторы имеются в C++? Приведите примеры их работы.</p></li>
<li><p>Что такое битовые флаги и битовые маски? Как в C++ записываются числа в системах счисления, отличных от десятичной?</p></li>
<li><p>Каким образом можно: а) объявить целочисленную переменную размером 8, 16, 32 бита (гарантированно); б) объявить битовый массив произвольно большого размера; в) поле структуры размера, не кратного байту (например, 9 бит)?</p></li>
<li><p>Как в C++ объявляются простые массивы (одномерные и многомерные), каков синтаксис их инициализации, доступа к отдельным элементам, определения размера?</p></li>
<li><p>Опишите шаблон класса <code>std::array&lt;T, N&gt;</code>, его назначение и преимущества использования по сравнению с простыми массивами.</p></li>
<li><p>Что такое строки в стиле C (C-style string) и какие средства работы с ними имеются в стандартной библиотеке C++?</p></li>
</ol>
    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А., Мохов&nbsp;А.&nbsp;С., Василькова&nbsp;П.&nbsp;Д. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2019&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="/study/courses/assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="/study/courses/assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
