# Лабораторная работа № 1 в 2019 г.

**Тема:** знакомство с языком C++ и CodeBlocks IDE.


## Совместная работа
   
   ###Задание:

   Необходимо построить гистограмму массива чисел.  
   Гистограмма представляет собой графическое изображение зависимости частоты попадания элементов 
   выборки в соответствующий интервал группировки.
   Гистограмма строится так:
   диапазон значений делится на несколько интервалов, высоты столбцов
   пропорциональны количеству значений в каждом интервале.  Пример вывода:

       1|*
       3|***
       7|*******
      11|***********
       6|******
       4|****
       1|*

   Вводится количество чисел, массив чисел и количество столбцов гистограммы.
   Требования к выводу:

   * Гистограмма должна целиком умещаться в 80×25 символов.
   * Наименьший ненулевой столбец должен быть высотой в одну ячейку,
     если при этом самый высокий столбец умещается в отведенное пространство.
   * Высоты столбцов ожидаются до 1000.

## Указания

1. Реализуем ввод данных.

   Объявляем переменные: `size_t` под количество чисел и столбцов,
   `vector<double>` под числа.  Отмечаем важность того, что количества —
   неотрицательные, а имена переменных понятные.

   Для ввода количества чисел используем цикл `for` со счетчиком.

2. Подсчитываем количество чисел в каждом интервале.

   1. Объявляем переменную-`vector<size_t>` под них. Сразу же задаем размер
      и начальные значения (`0`). 


   2. При подсчете нам нужен наибольший и наименьший элемент, они ищутся циклом.

      **Примечание** Мы рассматриваем не *i*-й, а просто *очередной*
      элемент — применяем лучшее средство выражения этого, `for` по диапазону.

   3. Изобретаем формулу; у сдавших ВМ-1 не должно быть с этим проблем.
      Если будут, логика такая: сначала придумываем для нормированных данных,
      затем нормируем их.

   4. При расчете нужно действительный результат преобразовать к целому,


3. Реализуем вывод данных, как планировали.

   1. Для каждого элемента массива количеств элементов печатаем, какое число *N*
      в этом элементе записано, пробел, `|` и столько же *(N)* звездочек.

   Начиная с этого пункта, отвлекаемся на пункт 4.

   2. Выравниваем подписи. Если число меньше 1000, печатаем пробел; если число
      меньше 100, печатаем еще один; то же самое для 10.  Затем печатаем само
      число.  Отмечаем, что это можно записать и более элегантно, но не нужно.

   3. Нормируем высоту столбцов, сначала рассуждаем.

      1. Во-первых, если самый высокий столбец умещается в 80 символов,
         нормировать не нужно.  Во-вторых, если он высотой *M* и не умещается,
         нарисован он должен быть 80-ю звездочками, но каждая будет означать
         не 1, а *f = M*/80 единиц.  Ясно, что *f* — коэффициент
         пропорциональности, на него нужно умножить высоту столбца,
         чтобы получить количество звездочек.

      2. Заметим, что в рассуждении вместо 80 должно быть (80 - 4), потому что
         4 символа тратится на подписи и ось.  Обращаем внимание на что в коде
         появились непонятные сходу числа.  Выносим 80 и 4 в константы, даем им
         говорящие имена, добавляем комментарии.  Обосновываем для себя, почему
         нужна неизменяемость.

      3. Корректируем код вывода по формуле.  Сталкиваемся с тем, что деление
         целых чисел работает не так, как в математике — используем приведение
         типов, теперь к `double`.  Обратное приведение уже знакомо.

4. Проверяем работу программы без хлопот.

   Очевидно, всегда можно запустить программу и ввести данные вручную,
   а затем оценить результат.  Но это неудобно делать часто и совсем неудобно,
   если данных много.  Можно было бы считывать из файла, но мы не умеем
   и пока C++ нам хватает.

   1. Оказывается, консоль — это не только страшное текстовое окно, но и способ
      сделать так, чтобы данные читались из файла, но программу при этом менять
      не надо было бы: используем перенаправление ввода.

      Дело в том, что на самом деле чтение ведется не с клавиатуры, а с некоего
      *стандартного ввода*, просто при работе консоли это клавиатура.
      Аналогично, печать происходит на *стандартный вывод*, при работе через
      консоль это монитор.  Но можно использовать как стандартные в/в файлы.

      1. Создадим простой файл с теми же данными, что вводились вручную.
         Запустим программу с перенаправлением и убедимся, что вывод ее
         такой же, как был при вводе вручную.

      2. Для более тщательного тестирования используем заготовленные файлы,
         размещенные на странице дисциплины.

   2. От ввода вручную мы избавились, но осталось еще сравнение результатов
      с эталонами.  Очевидно, компьютер и это может сделать сам.  В Windows
      для этого есть программа `fc` (file compare), которая сравнивает два
      файла.  Значит, нужно и результат работы программы записывать в файл,
      а не выводить на экран — перенаправление позволяет и это.

      * Подадим на стандартный ввод файл-пример и сравним его
        с файлом-эталоном, размещенным также на странице курса.
        Результат — «рисунок» совпадает, но другие строки отличаются.

   3. Проблема: часть вывода является значимой, полезной, а часть вывода
      носит декоративный характер.  К сожалению, только в программе известно,
      что выводится как полезные данные, а что — как декоративные; не обойтись
      без изменения кода.  Тем не менее, после этого хочется иметь
      возможность считывать только полезные данные, не уведомляя об этом
      программу.

      Оказывается, кроме стандартного вывода есть еще и *стандартный вывод
      для ошибок*.  Такое название сложилось исторически, но на самом деле
      как раз туда принято выводить декоративные сообщения.  В C++ это можно
      сделать, используя не `cout`, а `cerr`.

      1. Изменим программу, направив все приглашения в `cerr`.  Заметим,
         что поведение программы при запуске и ручном вводе не изменилось.

      2. Повторим ввод из заготовленного файла и сравнение с эталоном.
         Можно заметить, что в качестве стандартного вывода ошибок по-прежнему
         используется консоль.  Сравнение показывает, что вывод программы
         (только стандартного ее вывода) идентичен эталону.



## Самостоятельная работа

### Вариант 1

Дайте пользователю возможность задавать произвольную ширину гистограммы вместо
80 символов.  Ширину менее 7, более 80 или менее трети количества чисел
считайте некорректной — предлагайте пользователю ввести ее заново в этом случае
с указанием причины.


### Вариант 2

Если пользователь вводит 0 как число столбцов, рассчитывайте число столбцов автоматически
по эмпирической формуле *K = √N*, а если получилось *K > 25*, пересчитайте
по правилу Стёрджеса: для *N* чисел количество столбцов *K = 1 + ⌊log₂N⌋*.
Печатайте, по какой формуле был сделан выбор и сколько столбцов выбрано.


### Вариант 3

Дайте пользователю возможность задавать высоту гистограммы *H* строк.
Если количество столбцов *K* в *C = ⌊H/K⌋* раз меньше *H*, столбцы должны
занимать по *C* строк, например, для *C = 2*:

     8|********
      |********
    11|***********
      |***********
     6|******
      |******


### Вариант 4

Вместо количества элементов сделайте подписью столбца процент элементов,
попавших в столбец, как целое двузначное число с `%` в конце.


### Вариант 5

Отображайте гистограмму зеркально, например:

       ********|  8
    ***********| 11
         ******|  6


### Вариант 6

Дайте пользователю возможность выбора символов для столбцов «рисунка», линии
оси (`|` в примерах) и для выравнивания подписей.  Например, при выборе
соответственно `o`, пробела и `0`:

    008 oooooooo
    011 ooooooooooo
    006 oooooo

Не позволяйте вводить символы табуляции и перевода строк, печатайте любое
сообщение со словом «ERROR» и завершайте программу при этом.


### Вариант 7

Вычислите среднюю высоту столбца.  Если столбец ниже, доведите его высоту
до средней символами `-`.  Если столбец выше, выводите часть, превышающую
среднюю высоту, символами `+`.  Пример (средняя высота — 8 звездочек):

     8|********
    11|********+++
     6|******--


### Вариант 8

После подсчета количеств значений в столбцах, замените их нарастающим итогом,
начиная с первого столбца.  При отображении соблюдайте те же правила,
что и ранее.  Пример для исходного графика 1-3-7-11-6-4-1:

       1|*
       4|****
      11|***********
      22|**********************
      28|****************************
      32|********************************
      33|*********************************

**Примечание.**  В математической статистике гистограммой называют именно
такой график, а исходный — распределением частот.


### Вариант 9

В каждом столбце, если предыдущий столбец ниже, вместо `*` используйте `^`
на высоте предыдущего столбца.  Аналогично для следующего столбца, но `v`.
Если соседние столбцы оба ниже текущего и равны, используйте `N`.  Пример:

       1|*
       3|^**
       7|**^****
      11|*****v^****
       6|***v**
       4|v***
       1|*


### Вариант 10

Отображайте гистограмму вертикально без подписей, например:

    *******
     *****
     *****
      ****
      ***
      ***
      **
       *

**Указание.**  Можно воспользоваться следующей логикой: проходить по всем
столбцам и печатать `*`, если высота столбца больше номера строки, или пробел,
если нет — и так до тех пор, пока на очередной строке печатается хотя бы одна
звездочка.


### Вариант 11

Добавьте рамку вокруг гистограммы.  Добавьте учет линий рамки, чтобы общая
ширина «изображения» не превышала 80 символов.  Иллюстрация результата:

    +----------------+
    |  8|********    |
    | 11|*********** |
    |  6|******      |
    +----------------+


### Вариант 12

Добавьте на ось подписей границы столбцов.  Например, если в первый столбец
отнесены элементы от наименьшего до 1,23, во второй — от 1,23 до 2,34 и т. д.,
желаемый результат:

         8|********
    1.23
        11|***********
    2.34
         6|******

Ширину места для подписей столбцов нужно увеличить, как на иллюстрации.


### Вариант 13

После вывода гистограммы запрашивайте у пользователя, доволен ли он результатом.
Если ответ отрицательный, позвольте ввести новое количество столбцов
и перестройте гистограмму.  Процесс может повторяться сколько угодно раз.


### Вариант 14

Сделайте подписи к столбцам текстовыми.  После ввода количества столбцов *K*
пользователь должен ввести *K* строк (возможно, с пробелами), которые будут
подписями к соответствующим столбцам.  При выводе гистограммы вместо высоты
каждого столбца нужно печатать его подпись.  Подписи должны быть выровнены
по правому краю на ширину самой длинной из них.


### Вариант 15

Добавьте горизонтальную шкалу под гистограммой.  Шкалу нужно разбить на интервалы,
размер которых от вводит пользователь.  Допустимы размеры от 4 до 9,
при некорректном вводе печатайте сообщение со словом «ERROR» и завершайте работу
программы.  Под нулевой, первой и последней отметкой шкалы требуется напечатать
соответствующие числа.  Шкала должна быть во всю ширину гистограммы.
Пример для интервала размером 6:

         8|********
        14|**************
        12|************
          |-----|-----|-----|
           0     6           18


### Вариант 16

Перед построением гистограммы удалите из входного массива все повторяющиеся
(не обязательно подряд) элементы и напечатайте результат.

**Указание.**  Удалить `xs[i]` можно так: `xs.erase(xs.begin() + i)`.


### Вариант 17

После ввода количества чисел предлагайте пользователю генерировать их.
При положительном ответе заполните исходный массив при помощи функции `rand()`:
каждый элемент должен быть суммой 12 ее результатов.

**Указание.**  В начале программы добавьте `srand(time(0))`, чтобы случайные
числа отличались между запусками программы (аналог `Randomize()` в Pascal).


### Вариант 18

Избавьте программу от предположения о наибольшем возможном количестве чисел
в столбце.  Находите наибольшее и используйте это значение, чтобы выровнять
подписи по правому краю, не расходуя при этом лишних знакомест.
