<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>РПОСУ. ЛР № 1. Основы языка C++</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div>
    <a href="http://uii.mpei.ru">Сайт кафедры</a> →
    <a href="/study/courses">Дисциплины ИТ</a> →
    <a href="/study/courses/cs">РПОСУ</a>
</div>
<header id="title-block-header">
<h1 class="title">РПОСУ. ЛР № 1. Основы языка C++</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#цель-работы">Цель работы</a></li>
<li><a href="#задание">Задание</a></li>
<li><a href="#указания-к-выполнению-работы">Указания к выполнению работы</a><ul>
<li><a href="#ввод-данных">Ввод данных</a></li>
<li><a href="#обработка-данных">Обработка данных</a><ul>
<li><a href="#определение-индекса-корзины-по-значению-элемента">Определение индекса корзины по значению элемента </a></li>
<li><a href="#определение-диапазона-чисел-в-массиве">Определение диапазона чисел в массиве</a></li>
<li><a href="#формирование-корзин">Формирование корзин</a></li>
</ul></li>
<li><a href="#вывод-данных">Вывод данных</a><ul>
<li><a href="#этап-1-минимально-работающий-вариант">Этап 1: минимально-работающий вариант</a></li>
<li><a href="#автоматическая-проверка-по-эталонному-вводу-и-выводу">Автоматическая проверка по эталонному вводу и выводу</a></li>
<li><a href="#этап-2.-выравнивание-подписей-столбцов">Этап 2. Выравнивание подписей столбцов </a></li>
<li><a href="#этап-3.-масштабирование-столбцов-гистограммы">Этап 3. Масштабирование столбцов гистограммы</a></li>
</ul></li>
</ul></li>
<li><a href="#варианты-индивидуальных-заданий">Варианты индивидуальных заданий</a></li>
</ul>
</nav>
<p><strong>Дополнительные материалы</strong> (в ЛР объясняется необходимый минимум):</p>
<ul>
<li><a href="http://cmd.readthedocs.io/cmd.html">Основы работы с командной строкой</a></li>
<li><a href="http://www.windowsfaq.ru/content/view/260/57/">Перенаправление стандартных потоков ввода и вывода</a></li>
<li><a href="http://ab57.ru/cmdlist/fc.html">Документация к программе FC</a></li>
</ul>
<h1 id="цель-работы">Цель работы</h1>
<ol type="1">
<li>Владеть базовыми конструкциями и типами языка C++.</li>
<li>Уметь работать в среде программирования CodeBlocks.</li>
<li>Уметь автоматически проверять программы по эталонному вводу и выводу.</li>
</ol>
<h1 id="задание">Задание</h1>
<ol type="1">
<li>Написать программу для построения гистограммы массива чисел.</li>
<li>Доработать программу в соответствии с вариантом.</li>
</ol>
<p>Гистограмма (bar plot) строится так: диапазон значений на входе делится на несколько равных интервалов (корзин, bins), подсчитывается количество  чисел, попавших в каждый интервал, и для каждой корзины рисуется столбец, размер которого пропорционален количеству попавших в корзину чисел.</p>
<p>Например, на вход поступают оценки 10 студентов:</p>
<pre class="text"><code>4 4 3 5 3 4 5 5 4 4</code></pre>
<p>Пусть требуется построить гистограмму на три столбца. Диапазон значений на входе — от 3 до 5. Каждый из трех интервалов будет шириной <em>(5 − 3) / 3 = 0,67,</em> то есть интервалы будут <em>[3; 3.67], [3.67; 4.34], [4.34; 5].</em> В первую корзину попадут тройки (2 шт.), во вторую — четверки (5 шт.), в пятую — пятерки (3 шт.). Результат:</p>
<pre class="text"><code>  2|**
  5|*****
  3|***</code></pre>
<p><strong>Требования к выводу:</strong></p>
<ul>
<li><p>Подписи к столбцам выровнены до трех знакомест (можно считать, что в корзину больше 999 чисел не попадет).</p></li>
<li><p>Ширина всей гистограммы (подписи и звездочек в каждом столбце) должна  укладываться в 80 симоволов. Если в корзину попало больше чисел, все столбцы нужно пропорционально сжать, чтобы выполнить условие.</p></li>
</ul>
<h1 id="указания-к-выполнению-работы">Указания к выполнению работы</h1>
<p>Алгоритм работы программы логично разделить на три этапа:</p>
<ol type="1">
<li>Ввод данных (считывание массива чисел и количества столбцов).</li>
<li>Обработка данных (расчет количества чисел, попавших в каждую корзину).</li>
<li>Вывод данных (отображение рассчитанных значений в виде гистограммы).</li>
</ol>
<p>Ввод данных составляет:</p>
<ol type="1">
<li>Ввод количества значений (целого числа).</li>
<li>Ввод значений (цикл, заполняющий массив).</li>
<li>Ввод количества корзин (целого числа).</li>
</ol>
<p>Обработка заключается в том, чтобы массив чисел преобразовать в массив их количеств в каждой корзине. Для этого нужно рассмотреть каждое число, узнать номер корзины, в которую оно попадает, и увеличить счетчик чисел для этой корзины.</p>
<p>Вывод данных имеет смысл выполнить в несколько подходов: сначала элементарно, чтобы убедиться в правильности обработки, затем реализовать требования к отображению.</p>
<ol type="1">
<li>Отображать для каждой корзины количество чисел в ней, ось и такое же количество звездочек, сколько чисел в корзине.</li>
<li>Выровнять подписи до трех знакомест.</li>
<li>Масштабировать высоты столбцов, чтобы уложиться в 80 символов.</li>
</ol>
<h2 id="ввод-данных">Ввод данных</h2>
<p>Входные данные (переменные): количество чисел, числа, количество корзин.</p>
<p>В C++ есть специальный тип <code>size_t</code>, подходящий для размеров массивов: целое неотрицательное число с широким диапазоном значений. Целесообразно  использовать его для количества чисел:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">size_t</span> number_count;</a></code></pre></div>
<p>Имя переменной сообщает, что в ней хранится: number count по-английски  «количество чисел». Всем переменным нужно давать осмысленные имена  (исключения: счетчики циклов <code>i</code>, <code>j</code>, … и математические формулы). Программы чаще читаются, чем пишутся — их понятность важнее размера. Скорости набора текста помогает редактор, подсказывающий имена по мере ввода.</p>
<p>Ввод стандартный:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">cout &lt;&lt; <span class="st">&quot;Enter number count: &quot;</span>;</a>
<a class="sourceLine" id="cb4-2" title="2">cin &gt;&gt; number_count;</a></code></pre></div>
<p>Отображение кириллицы в консоли Windows требует ухищрений. Применять их не нужно, во всех ЛР достаточно англоязычного вывода.</p>
<p>Массив значений состоит из действительных чисел, выберем для них тип <code>double</code>. Размер массива определяется во время работы программы переменной <code>number_count</code>, то есть это динамический массив. Его можно реализовать через <code>new[]</code>/<code>delete[]</code>, но в современном C++ принято использовать вектор, в данном случае — <code>vector&lt;double&gt;</code>.</p>
<p>Для использования <code>vector&lt;T&gt;</code> нужно подключить часть стандартной библиотеки:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a></code></pre></div>
<p>При объявлении переменной <code>numbers</code> (числа) типа <code>vector&lt;T&gt;</code> можно сразу указать размер:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">vector&lt;<span class="dt">double</span>&gt; numbers(number_count);</a></code></pre></div>
<p>Очевидно, это нужно делать после ввода <code>number_count</code>. Если бы <code>numbers</code> была объявлена до этого, ей не нужно было бы передавать аргумент в скобках; вместо этого после ввода <code>number_count</code> нужно было бы изменить размер:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1">numbers.resize(number_count);</a></code></pre></div>
<p>Однако безопаснее объявлять переменные как можно ближе к месту первого использования: меньше риск случайно обратиться к ним до инициализации. Например, если объявить <code>numbers</code> в начале программы, ничто не помешает обратиться к его элементам до вызова <code>resize()</code>, что приведет к ошибке.</p>
<p>Числа вводятся в <code>numbers</code> стандартным циклом <code>for</code> со счетчиком. Код нужно написать самостоятельно.</p>
<p>Количество корзин <code>bin_count</code> целесообразно сделать того же типа, что и <code>number_count</code> и вводить так же.</p>
<h2 id="обработка-данных">Обработка данных</h2>
<p>Необходимо для каждой корзины подсчитать количество попавших в нее чисел, то есть заполнить массив счетчиков. Тип счетчика — <code>size_t</code>, потому что  это по сути такое же количество, как количество чисел. Их массив имеет размер <code>bin_count</code>, а начальные значения в нем — нули:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">vector&lt;<span class="dt">size_t</span>&gt; bins(bin_count, <span class="dv">0</span>);</a></code></pre></div>
<p>Как по значению элемента определить номер корзины, куда он попадает?</p>
<h3 id="определение-индекса-корзины-по-значению-элемента">Определение индекса корзины по значению элемента </h3>
<p>Рассмотрим сначала простой случай, когда значения распределены от нуля до некоторого максимума <code>high</code>. Тогда, чтобы получить индекс корзины по значению элемента, нужно поделить значение на ширину столбца и отбросить дробную часть. Ширина столбца будет <code>(high / bin_count)</code>. Как перейти к этому простому случаю от исходного? Очевидно, чтобы перевести значение из <code>[min; max]</code> в <code>[0; high]</code> можно вычесть из значения <code>min</code>, тогда <code>high = max - min</code>. Подстановка в итоговую формулу дает (это выражение появится в программе позже):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">size_t</span> bin_index = (number - min) * bin_count / (max - min);</a></code></pre></div>
<p>Можно рассуждать и по-другому. Очевидно, что минимальный элемент попадет в первую корзину (с индексом 0), максимальный — в последнюю корзину, а элемент, значение которого посередине между ними — в корзину посередине. Можно ожидать, что формула будет линейным преобразованием числа <code>number</code> в индекс корзины <code>bin_index</code>:</p>
<pre class="text"><code>bin_index = factor * (number + shift)</code></pre>
<p>Определим, чем равны коэффициенты <code>factor</code> (множитель) и <code>shift</code> (сдвиг). Минимум <code>min</code> должен переходить в индекс 0:</p>
<pre class="text"><code>0 = factor * (min + shift)              (1)</code></pre>
<p>Максимум должен переходить в <code>bin_count</code>:</p>
<pre class="text"><code>bin_count = factor * (max + shift)      (2)</code></pre>
<p>Решив систему (1) и (2) относительно <code>factor</code> и <code>shift</code>, находим:</p>
<pre class="text"><code>factor = bin_count / (max - min)
shift  = -min</code></pre>
<p>Получается такая же формула для расчета номера столбца:</p>
<pre class="text"><code>size_t bin_index = column_count * (number - min) / (max - min);</code></pre>
<p>Тип <code>size_t</code> для <code>bin_index</code> несомненный — такой же, как количество корзин. Результат деления будет дробным, однако C++ отбрасывает дробную часть, если дробное выражение присвоить целочисленной переменной.</p>
<p>Можно заметить, что при <code>number == max</code> значение <code>bin_index</code> будет <code>bin_count</code>, а это недопустимый индекс для массива <code>bins</code>. Выходом будет после расчета по формуле уменьшать <code>bin_count</code> на 1 в этом случае. Ошибка появилась потому, что в формуле смешаны непрерывные и целочисленные операции.</p>
<h3 id="определение-диапазона-чисел-в-массиве">Определение диапазона чисел в массиве</h3>
<p>Для расчета индексов столбцов нужно найти наибольший и наименьший элементы в массиве. Разберем эту простую задачу подробно, чтобы изучить диапазонный цикл <code>for</code> (range-based for loop). Формулировка решения: <em>для каждого</em> массива  чисел сравнить его с максимумом и минимумом, при необходимости скорректировать максимум или минимум. Заметим, что решение не оперирует индексами  в массиве — только значением очередного элемента. Для выражение этой идеи  в C++ есть диапазонный цикл <code>for</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">double</span> min = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="dt">double</span> max = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="cf">for</span> (<span class="dt">double</span> x : numbers) {</a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="cf">if</span> (x &lt; min) {</a>
<a class="sourceLine" id="cb15-5" title="5">        min = x;</a>
<a class="sourceLine" id="cb15-6" title="6">    }</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="cf">else</span> <span class="cf">if</span> (x &gt; max) {</a>
<a class="sourceLine" id="cb15-8" title="8">        max = x;</a>
<a class="sourceLine" id="cb15-9" title="9">    }</a>
<a class="sourceLine" id="cb15-10" title="10">}</a></code></pre></div>
<p>Запись <code>for (double x : numbers) { ... }</code> означает: выполнить тело цикла  <em>для каждого</em> элемента <code>x</code> (типа <code>double</code>) из массива <code>numbers</code>, то есть в точности соответствует логике решения.</p>
<p>Отметим оформление кода:</p>
<ul>
<li>вокруг операторов (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>), после ключевых слов (<code>for</code>, <code>if</code>) и перед фигурными скобками (<code>{</code>) стоят пробелы;</li>
<li>блоки кода (тело цикла, инструкции под условиями) выделены отступами.</li>
</ul>
<p>Как и имена переменных, форматирование кода (code style) помогает понимать смысл программы (ее структуру) и страхует от ошибок. Чтобы автоматически  отформатировать код в CodeBlocks, нужно щелкнуть по тексту правой кнопкой мыши и выбрать <em>Format (use AStyle)</em> (если выделить фрагмент, отформатирован будет только он).</p>
<h3 id="формирование-корзин">Формирование корзин</h3>
<p>Для заполнения счетчиков чисел в корзинах нужно для каждого элемента <code>number</code> в массиве <code>numbers</code> рассчитать индекс его корзины <code>bin_index</code> и увеличить на единицу счетчик <code>bins[bin_index]</code>. Код нужно написать самостоятельно.</p>
<h2 id="вывод-данных">Вывод данных</h2>
<h3 id="этап-1-минимально-работающий-вариант">Этап 1: минимально-работающий вариант</h3>
<p>Для каждого элемента <code>bin</code> массива <code>bins</code> нужно вывести значение <code>bin</code>, символ <code>|</code> и <em>bin</em> звездочек (внутренним циклом со счетчиком); после звездочек нужен перевод строки. Код нужно написать самостоятельно.</p>
<p>На этом этапе можно проверить работу программы: ввести данные из примера  (десять чисел, три корзины) и визуально сопоставить гистограммы.</p>
<p>На последующих этапах нужно будет проверять работу программы на десятках чисел, вводить которые долго и чревато ошибками. Можно записать числа в файл и вставлять в консоль, но сравнивать результаты (считать звездочки) не легче. Проблема усугубляется, если нужно проводить много тестов.</p>
<h3 id="автоматическая-проверка-по-эталонному-вводу-и-выводу">Автоматическая проверка по эталонному вводу и выводу</h3>
<p>Можно полностью автоматически вводить данные в программу, сохранять ее вывод и сравнивать с эталоном, получая простой ответ: пройден ли тест.</p>
<p>Эталонный ввод при этом читается из файла, вывод записывается в файл, который затем сравнивается с файлом эталонного вывода. При этом не требуется добавлять в программу работу с файлами и логику проверки, если знать, как устроен ввод и вывод, и уметь пользоваться стандартными утилитами.</p>
<p>Дальнейшая работа ведется в консоли из каталога с файлом <code>*.exe</code>, в CodeBlocks это может быть <code>bin\Debug</code>. При затруднениях в работе с консолью можно воспользоваться <a href="http://cmd.readthedocs.io/cmd.html">руководством</a>.</p>
<h4 id="командная-строка-windows">Командная строка Windows</h4>
<p>Командная строка (терминал) запускается через <em>Win+R</em>, <code>cmd</code> или путем ввода <code>cmd</code> в строку адреса в «Проводнике» и нажатия <em>Enter.</em> Текст <code>C:\&gt;</code> слева от курсора называется <em>приглашением (prompt).</em> Приглашение показывает текущий каталог — корень диска C. Перейти в другой каталог можно командой <code>cd</code>, например, <code>cd lab01</code>. Если нужно перейти на другой диск, добавляется <em>ключ (опция)</em> <code>/d</code>, например: <code>cd /d L:\A-01-18\username</code>. Чтобы не вводить путь вручную, можно нажимать <em>Tab</em> после ввода первых символов имени каталога, и Windows дополнит путь. Если нужно повторить одну из предыдущих команд, стрелки вверх и вниз проматывают историю.</p>
<h4 id="стандартные-потоки-и-их-перенаправление">Стандартные потоки и их перенаправление</h4>
<p>Обычно для простоты говорят, что ввод происходит с клавиатуры, а вывод — на  экран. На самом деле ввод происходит из особого устройства — <em>стандартного ввода (standard input, stdin),</em> а вывод поступает на устройство <em>стандартного вывода (standard output, stdout).</em> По умолчанию стандартный ввод связан с клавиатурой, а вывод — с терминалом (окном консоли в Windows). Однако можно при запуске программы указать, что стандартным вводом для нее будет не клавиатура, а файл <em>(перенаправление ввода, input redirection):</em></p>
<pre class="shell"><code>C:\lab01&gt; lab01.exe &lt; 01-example.input.txt
Enter number count: Enter numbers: Enter bin count: 2|**
5|*****
3|***</code></pre>
<ul>
<li>эталонный ввод <a href="01-example.input.txt">01-example.input.txt</a></li>
<li>эталонный вывод <a href="01-example.expected.txt">01-example.expected.txt</a></li>
</ul>
<p>Видно, что гистограмма строится правильно, но картину портят приглашения ввода (<code>Enter number count</code> и прочие).</p>
<p>Аналогично можно направить стандартный вывод в файл:</p>
<pre class="shell"><code>C:\lab01&gt; lab01.exe &lt; 01-example.input.txt &gt; 01-example.actual.txt</code></pre>
<p>Вывода на терминал нет — он весь в <code>01-example.actual.txt</code>, и если его просмотреть, окажется, что он соответствует предшествующему выводу.</p>
<p>Как избавиться от приглашений, которые не нужны в режиме автоматических тестов? Проблема заключается в том, что у программы есть значимый, информативный вывод (собственно гистограмма), а есть декоративный вывод (приглашения). Только самой программе «известно», где какой вывод — без ее модификации не обойтись.</p>
<p>Помимо стандартного вывода существует <em>стандартный вывод ошибок (stderr).</em> Такое название сложилось исторически, а на практике принято писать в него декоративный вывод. Этот поток доступен в C++ как <code>cerr</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1">cerr &lt;&lt; <span class="st">&quot;Enter number count: &quot;</span>;</a></code></pre></div>
<p>Нужно самостоятельно заменит вывод приглашений (но не гистограммы) в <code>cout</code> на их вывод в <code>cerr</code>.</p>
<p>Если теперь запустить программу как обычно (без перенаправления), ее работа  внешне не изменится, потому что стандартный вывод ошибок по умолчанию тоже связан с терминалом. Если же перенаправить вывод в файл, записанное в <code>cerr</code> появится в терминале, но не в файле <code>01-example.actual.txt</code>:</p>
<pre class="shell"><code>C:\lab01&gt; lab01.exe &lt; 01-example.input.txt &gt; 01-example.actual.txt
Enter number count: Enter numbers: Enter bin count:</code></pre>
<p>Чтобы убрать декоративный вывод при автоматических тестах, можно направить его в специальное устройство <code>NUL</code>, которое поглощает любой вывод в него:</p>
<pre class="shell"><code>C:\lab01&gt; lab01.exe &lt; 01-example.input.txt &gt; 01-example.actual.txt 2&gt;NUL</code></pre>
<p>Вывода в терминал при этом нет никакого, хотя программа успешно работает.</p>
<p>При желании с перенаправлением можно ознакомиться <a href="http://www.windowsfaq.ru/content/view/260/57/">подробнее</a>.</p>
<h4 id="сравнение-файлов">Сравнение файлов </h4>
<p>Программа <code>fc</code> (file compare) позволяет построчно сравнить файл вывода  программы <code>01-example.actual.txt</code> с файлом <code>01-example.expected.txt</code>, содержащим эталонный вывод:</p>
<pre class="shell"><code>C:\lab01&gt; fc 01-example.actual.txt 01-example.expected.txt
Сравнение файлов 01-example.actual.txt и 01-EXAMPLE.EXPECTED.TXT
FC: различия не найдены</code></pre>
<p>Если бы были отличия, <code>fc</code> могла бы показать отличающиеся строки, а с ключом <code>/N</code> также и их номера (<a href="http://ab57.ru/cmdlist/fc.html">справка</a>):</p>
<pre class="shell"><code>C:\lab01&gt; fc /N 01-example.actual.txt 02-alignment.expected.txt
Сравнение файлов 01-example.actual.txt и 02-ALIGNMENT.EXPECTED.TXT
***** 01-example.actual.txt
    1:  2|**
    2:  5|*****
    3:  3|***
***** 02-ALIGNMENT.EXPECTED.TXT
    1:    2|**
    2:    5|*****
    3:    3|***
*****</code></pre>
<h4 id="bat-файлы">BAT-файлы</h4>
<p>Чтобы не вводить каждый раз команды вручную, их можно записать в файл с расширением <code>*.bat</code> и запускать как программу из командной строки:</p>
<pre><code>lab01.exe &lt; 01-example.input.txt &gt; 01-example.actual.txt 2&gt;NUL
fc /N 01-example.actual.txt 01-example.expected.txt</code></pre>
<p>Чтобы запускать файл из «Проводника» и при ошибках окно не закрывалось, можно к последней строки добавить <code>|| pause</code>.</p>
<h3 id="этап-2.-выравнивание-подписей-столбцов">Этап 2. Выравнивание подписей столбцов </h3>
<p>Требуется количество чисел, попавших в каждый столбец, дополнять при выводе пробелами так, чтобы суммарно подпись занимала четыре знакоместа (символа). Хотя в C++ и есть средства форматирования, реализуем выравнивание вручную:</p>
<ol type="1">
<li>Если число меньше 100, вывести пробел (он займет место разряда сотен).</li>
<li>Если число меньше 10, вывести пробел (он займет место разряда десятков).</li>
<li>Вывести число.</li>
</ol>
<p>Необходимо написать код самостоятельно и автоматически проверить его:</p>
<ul>
<li>эталонный ввод <a href="02-alignment.input.txt">02-alignment.input.txt</a>;</li>
<li>эталонный вывод <a href="02-alignment.expected.txt">02-alignment.expected.txt</a>.</li>
</ul>
<h3 id="этап-3.-масштабирование-столбцов-гистограммы">Этап 3. Масштабирование столбцов гистограммы</h3>
<p>Поскольку ограничена ширина всей гистограммы (включая подписи и ось), ограничение на длину столбца будет <em>80 − 4 − 1 = 75</em> символов.</p>
<p>Если в корзине самым большим количеством чисел не больше 75, масштабирование не нужно.</p>
<p>Для масштабирования из количества чисел <code>count</code> в каждой корзине нужно  получить ее высоту <code>height</code> (количество звездочек). Масштабирование должно  работать так, чтобы самый высокий столбец имел 75 звездочек, следовательно, для него <code>height = 75 * 1.0</code>. Для прочих корзин вместо 1,0 должен быть множитель-доля количества чисел в этой корзине от максимального количества: <code>height = 75 * count / max_count</code>. Однако напрямую эту формулу записать на C++ нельзя: деление целых чисел <code>count</code> и <code>max_count</code> даст целое же число.</p>
<p>Необходимо указать компилятору, что <code>count</code> нужно рассматривать как дробное. Это называется приведением типов (type cast):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">size_t</span> height = <span class="dv">75</span> * (<span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(count) / max_count);</a></code></pre></div>
<p>Выражение <code>static_cast&lt;T&gt;(x)</code> означает: рассматривать выражение <code>x</code> как имеющее тип <code>T</code>. Можно встретить другую форму записи, так называемое приведение в стиле C (C-style cast): <code>((double)count)</code>. Почему в C++ более громоздкий синтаксис? Дело в том, что приведение типов — это место  в программе, где программист берет на себя ответственность, что преобразование имеет смысл, поэтому лучше, когда оно резко выделяется в тексте программы.</p>
<p>Заметим, что в данном примере можно было бы обойтись вообще без приведения типов, если сделать <code>max_count</code> типа <code>double</code>, однако приведение типов  часто встречается на практике — необходимо уметь его делать.</p>
<p>Константа 75 используется как минимум в двух местах, что плохо. во-первых, если потребуется поменять ее, придется искать и редактировать все эти места. Во-вторых, при чтении кода будет непонятен ее смысл. По последней причине  такие числа в коде называются магическими константами. Их нужно выносить в неизменяемые переменные с понятными именами или комментариями. Обычно  их размещают в самом начале программы:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="at">const</span> <span class="dt">size_t</span> SCREEN_WIDTH = <span class="dv">80</span>;</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="at">const</span> <span class="dt">size_t</span> MAX_ASTERISK = SCREEN_WIDTH - <span class="dv">4</span> - <span class="dv">1</span>;</a></code></pre></div>
<p>Итак, требуется самостоятельно реализовать:</p>
<ol type="1">
<li>Поиск наибольшего количества чисел в одной корзине (можно совместить в подсчетом чисел в корзинах).</li>
<li>Масштабирование столбцов.</li>
</ol>
<p>Результат необходимо автоматически проверить:</p>
<ul>
<li>эталонный ввод <a href="03-scaling.input.txt">03-scaling.input.txt</a></li>
<li>эталонный вывод <a href="03-scaling.expected.txt">03-scaling.expected.txt</a></li>
</ul>
<h1 id="варианты-индивидуальных-заданий">Варианты индивидуальных заданий</h1>
<p>Решение должно включать: код программы, файлы эталонного ввода и вывода, BAT-файл для автоматической проверки.</p>
<h4 id="вариант-1">Вариант 1</h4>
<p>Дайте пользователю возможность задавать произвольную ширину гистограммы вместо 80 символов. Ширину менее 7, более 80 или менее трети количества чисел считайте некорректной — предлагайте пользователю ввести ее заново в этом случае с указанием причины.</p>
<h4 id="вариант-2">Вариант 2</h4>
<p>Если пользователь вводит 0 как число столбцов, рассчитывайте число столбцов автоматически по эмпирической формуле <em>K = √N</em>, а если получилось <em>K &gt; 25</em>, пересчитайте по правилу Стёрджеса: для <em>N</em> чисел количество столбцов <em>K = 1 + ⌊log₂N⌋</em>. Печатайте, по какой формуле был сделан выбор и сколько столбцов выбрано.</p>
<p><strong>Указание.</strong> См. функции <code>sqrt()</code> и <code>log2</code> из <code>&lt;cmath&gt;</code>.</p>
<h4 id="вариант-3">Вариант 3</h4>
<p>Дайте пользователю возможность задавать высоту гистограммы <em>H</em> строк. Если количество столбцов <em>K</em> в <em>C = ⌊H/K⌋</em> раз меньше <em>H</em>, столбцы должны занимать по <em>C</em> строк.</p>
<p><strong>Пример.</strong> Выбрано <em>H = 6, K = 3 ⇒ C = 2,</em> гистограмма:</p>
<pre><code> 8|********
  |********
11|***********
  |***********
 6|******
  |******</code></pre>
<h4 id="вариант-4">Вариант 4</h4>
<p>Вместо количества элементов сделайте подписью столбца процент элементов, попавших в столбец, как целое двузначное число с <code>%</code> в конце.</p>
<h4 id="вариант-5">Вариант 5</h4>
<p>Отображайте гистограмму зеркально, например:</p>
<pre><code>   ********|  8
***********| 11
     ******|  6</code></pre>
<h4 id="вариант-6">Вариант 6</h4>
<p>Дайте пользователю возможность выбора символов для столбцов «рисунка», линии оси (<code>|</code> в примерах) и для выравнивания подписей. Например, при выборе соответственно <code>|</code>, пробела и <code>0</code>:</p>
<pre><code>008 ||||||||
011 |||||||||||
006 ||||||</code></pre>
<p>Не позволяйте вводить символы табуляции и перевода строк, печатайте любое сообщение со словом «ERROR» и завершайте программу при этом.</p>
<h4 id="вариант-7">Вариант 7</h4>
<p>Вычислите среднюю высоту столбца. Если столбец ниже, доведите его высоту до средней символами <code>-</code>. Если столбец выше, выводите часть, превышающую среднюю высоту, символами <code>+</code>. Пример (средняя высота — 8 звездочек):</p>
<pre><code> 8|********
11|********+++
 6|******--</code></pre>
<h4 id="вариант-8">Вариант 8</h4>
<p>После подсчета количеств значений в столбцах, замените их нарастающим итогом, начиная с первого столбца. При отображении соблюдайте те же правила, что и ранее. Пример для исходного графика с высотами 1-3-7-11-6-4-1:</p>
<pre><code>   1|*
   4|****
  11|***********
  22|**********************
  28|****************************
  32|********************************
  33|*********************************</code></pre>
<h4 id="вариант-9">Вариант 9</h4>
<p>В каждом столбце, если предыдущий столбец ниже, вместо <code>*</code> используйте <code>^</code> на высоте предыдущего столбца. Аналогично для следующего столбца, но <code>v</code>. Если соседние столбцы оба ниже текущего и равны, используйте <code>N</code>. Пример:</p>
<pre><code>   1|*
   3|^**
   7|**^****
  11|*****v^****
   6|***v**
   4|v***
   1|*</code></pre>
<h4 id="вариант-10">Вариант 10</h4>
<p>Отображайте гистограмму вертикально без подписей, например:</p>
<pre><code>*******
 *****
 *****
  ****
  ***
  ***
  **
   *</code></pre>
<p><strong>Указание.</strong> Можно воспользоваться следующей логикой: проходить по всем столбцам и печатать <code>*</code>, если высота столбца больше номера строки, или пробел, если нет — и так до тех пор, пока на очередной строке печатается хотя бы одна звездочка.</p>
<h4 id="вариант-11">Вариант 11</h4>
<p>Добавьте рамку вокруг гистограммы. Добавьте учет линий рамки, чтобы общая ширина «изображения» не превышала 80 символов. Иллюстрация результата:</p>
<pre><code>+----------------+
|  8|********    |
| 11|*********** |
|  6|******      |
+----------------+</code></pre>
<h4 id="вариант-12">Вариант 12</h4>
<p>Добавьте на ось подписей границы столбцов. Например, если в первый столбец отнесены элементы от наименьшего до 1,23, во второй — от 1,23 до 2,34 и т. д., желаемый результат:</p>
<pre><code>     8|********
1.23
    11|***********
2.34
     6|******</code></pre>
<p>Ширину места для подписей столбцов нужно увеличить, как на иллюстрации.</p>
<h4 id="вариант-13">Вариант 13</h4>
<p>После вывода гистограммы запрашивайте у пользователя, доволен ли он результатом. Если ответ отрицательный, позвольте ввести новое количество столбцов и перестройте гистограмму. Процесс может повторяться сколько угодно раз.</p>
<h4 id="вариант-14">Вариант 14</h4>
<p>Сделайте подписи к столбцам текстовыми. После ввода количества столбцов <em>K</em> пользователь должен ввести <em>K</em> строк (возможно, с пробелами), которые будут подписями к соответствующим столбцам. При выводе гистограммы вместо высоты каждого столбца нужно печатать его подпись. Подписи должны быть выровнены по правому краю на ширину самой длинной из них.</p>
<h4 id="вариант-15">Вариант 15</h4>
<p>Добавьте горизонтальную шкалу под гистограммой. Шкалу нужно разбить на интервалы, размер которых от вводит пользователь. Допустимы размеры от 4 до 9, при некорректном вводе печатайте сообщение со словом «ERROR» и завершайте работу программы. Под нулевой, первой и последней отметкой шкалы требуется напечатать соответствующие числа. Шкала должна быть во всю ширину гистограммы. Пример для интервала размером 6:</p>
<pre><code>     8|********
    14|**************
    12|************
      |-----|-----|-----|
      0     6           18</code></pre>
<h4 id="вариант-16">Вариант 16</h4>
<p>Перед построением гистограммы удалите из входного массива все повторяющиеся (не обязательно подряд) элементы и напечатайте результат.</p>
<p><strong>Указание.</strong> Удалить <code>xs[i]</code> можно так: <code>xs.erase(xs.begin() + i)</code>.</p>
<h4 id="вариант-17">Вариант 17</h4>
<p>После ввода количества чисел предлагайте пользователю генерировать их. При положительном ответе заполните исходный массив при помощи функции <code>rand()</code>: каждый элемент должен быть суммой 12 ее результатов.</p>
<p><strong>Указание.</strong> В начале программы добавьте <code>srand(time(0))</code>, чтобы случайные числа отличались между запусками программы (аналог <code>Randomize()</code> в Pascal). Для составления эталонного вывода замените <code>time(0)</code> на 42.</p>
<h4 id="вариант-18">Вариант 18</h4>
<p>Избавьте программу от предположения о наибольшем возможном количестве чисел в столбце. Находите наибольшее и используйте это значение, чтобы выровнять подписи по правому краю, не расходуя при этом лишних знакомест.</p>
    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А., Мохов&nbsp;А.&nbsp;С., Василькова&nbsp;П.&nbsp;Д. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2019&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="/study/courses/assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="/study/courses/assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
