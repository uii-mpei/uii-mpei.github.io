<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>РПОСУ. ЛР № 3. Функции и структуры</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div>
    <a href="http://uii.mpei.ru">Сайт кафедры</a> →
    <a href="/study/courses">Дисциплины ИТ</a> →
    <a href="/study/courses/cs">РПОСУ</a>
</div>
<header id="title-block-header">
<h1 class="title">РПОСУ. ЛР № 3. Функции и структуры</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#цель-работы">Цель работы</a></li>
<li><a href="#часть-1.-декомпозиция-программы-функциями">Часть 1. Декомпозиция программы функциями</a><ul>
<li><a href="#задание">Задание</a></li>
<li><a href="#указания">Указания</a><ul>
<li><a href="#функция-ввода-чисел">Функция ввода чисел</a></li>
<li><a href="#вывод-типов-переменных">Вывод типов переменных</a></li>
<li><a href="#функция-поиска-минимума-и-максимума">Функция поиска минимума и максимума</a></li>
<li><a href="#передача-по-константной-ссылке">Передача по константной ссылке</a></li>
</ul></li>
<li><a href="#декомпозиция-программы">Декомпозиция программы</a></li>
</ul></li>
<li><a href="#часть-2.-вывод-гистограммы-как-изображения-в-формате-svg">Часть 2. Вывод гистограммы как изображения в формате SVG</a><ul>
<li><a href="#задача">Задача</a></li>
<li><a href="#указания-1">Указания</a><ul>
<li><a href="#вывод-заголовка-и-окончания-svg">Вывод заголовка и окончания SVG</a></li>
<li><a href="#функции-вывода-элементов-svg">Функции вывода элементов SVG</a></li>
<li><a href="#исключение-магических-констант">Исключение «магических констант»</a></li>
<li><a href="#вывод-гистограммы">Вывод гистограммы</a></li>
<li><a href="#оформление-гистограммы.-значения-параметров-по-умолчанию">Оформление гистограммы. Значения параметров по умолчанию</a></li>
</ul></li>
</ul></li>
<li><a href="#часть-3.-модульное-тестирование">Часть 3. Модульное тестирование</a><ul>
<li><a href="#задача-1">Задача</a></li>
<li><a href="#указания-2">Указания</a><ul>
<li><a href="#выделение-тестируемой-функции-в-модуль">Выделение тестируемой функции в модуль</a></li>
<li><a href="#создание-проекта-для-модульных-тестов">Создание проекта для модульных тестов</a></li>
<li><a href="#написание-модульных-тестов">Написание модульных тестов</a></li>
</ul></li>
</ul></li>
<li><a href="#часть-4.-использование-структур-перечислений-и-операторов">Часть 4. Использование структур, перечислений и операторов</a><ul>
<li><a href="#задача-2">Задача</a></li>
<li><a href="#указания-3">Указания</a><ul>
<li><a href="#план-решения">План решения</a></li>
<li><a href="#section">…</a></li>
</ul></li>
</ul></li>
<li><a href="#введение">Введение</a></li>
<li><a href="#постановка-задачи">Постановка задачи</a></li>
<li><a href="#план-решения-1">План решения</a></li>
<li><a href="#ввод-данных">Ввод данных</a></li>
</ul>
</nav>
<hr />
<h1 id="цель-работы">Цель работы</h1>
<ol type="1">
<li>Уметь структурировать программу при помощи функций и структур.</li>
<li>Уметь писать модульные тесты.</li>
</ol>
<h1 id="часть-1.-декомпозиция-программы-функциями">Часть 1. Декомпозиция программы функциями</h1>
<h2 id="задание">Задание</h2>
<p>Программа для построения гистограммы из ЛР № 1 состоит из одной функции <code>main()</code> на более чем 100 строк, из-за чего в ней неудобно ориентироваться. Необходимо выделить части программы в функции:</p>
<ul>
<li>Ввод чисел:
<ul>
<li>принимает количество чисел, которое необходимо ввести;</li>
<li>возвращает вектор чисел.</li>
</ul></li>
<li>Поиск наибольшего и наименьшего значения:
<ul>
<li>принимает вектор чисел;</li>
<li>возвращает два результата — min и max.</li>
</ul></li>
<li>Расчет гистограммы:
<ul>
<li>принимает вектор чисел и количество корзин;</li>
<li>возвращает вектор количеств чисел в каждой корзине;</li>
<li><em>вызывает</em> в процессе работы функцию поиска min и max.</li>
</ul></li>
</ul>
<h2 id="указания">Указания</h2>
<h3 id="функция-ввода-чисел">Функция ввода чисел</h3>
<p>Сколько параметров у функции? Один — количество вводимых чисел. Сколько и каких значений функция возвращает? Одно значение — вектор из действительных чисел. Что функция позволяет <em>сделать?</em> Ввести числа (input numbers). Таким образом, функция имеет вид:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">vector&lt;<span class="dt">double</span>&gt;</a>
<a class="sourceLine" id="cb1-2" title="2">input_numbers(<span class="dt">size_t</span> count) {</a>
<a class="sourceLine" id="cb1-3" title="3">    vector&lt;<span class="dt">double</span>&gt; result(count);</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; count; i++) {</a>
<a class="sourceLine" id="cb1-5" title="5">        cin &gt;&gt; result[i];</a>
<a class="sourceLine" id="cb1-6" title="6">    }</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>Современный C++ (C++11 и выше) позволяет просто возвращать из функции вектор, и это будет работать эффективно, каков бы ни был его размер.</p>
<p>В основной программе (в функции <code>main()</code>) ввод чисел заменяется вызовом новой функции:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">size_t</span> number_count;</a>
<a class="sourceLine" id="cb2-2" title="2">cin &gt;&gt; number_count;</a>
<a class="sourceLine" id="cb2-3" title="3">vector&lt;<span class="dt">double</span>&gt; numbers = input_numbers(number_count);</a></code></pre></div>
<h3 id="вывод-типов-переменных">Вывод типов переменных</h3>
<p>Выбран ли тип переменной <code>numbers</code> наилучшим образом?</p>
<p>Можно заметить, что в дальнейшем <code>numbers</code> не изменяется, следовательно, можно сделать ее константной:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="at">const</span> vector&lt;<span class="dt">double</span>&gt; numbers = input_numbers(number_count);</a></code></pre></div>
<p>Теперь тип <code>numbers</code> занимает половину строки, что может быть неудобно читать. Можно заметить, что тип <code>numbers</code> обязан совпадать с типом возвращаемого значения функции <code>input_numbers()</code>, то есть избыточен. В современном С++ есть способ указать компилятору <em>вывести</em> тип переменной <code>numbers</code> из выражения, которое ей присваивается:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="at">const</span> <span class="kw">auto</span> numbers = input_numbers(number_count);</a></code></pre></div>
<p><strong>Ключевое слово <code>auto</code> не вводит новый тип.</strong> Переменная <code>numbers</code> по-прежнему является <code>const vector&lt;double&gt;</code>, просто это записано короче, так как компилятору это известно без явного указания. Стала ли программа более читаемой? Ответ неоднозначен. Код сократился, но теперь из него не очевидно (человеку), каков тип <code>numbers</code>; с другой стороны, читателю может и не быть важно, как представлены <code>numbers</code> — достаточно того, что там числа (это ясно из названия функции). Вывод: использовать <code>auto</code> следует там, где это сокращает код без сокрытия важных подробностей.</p>
<h3 id="функция-поиска-минимума-и-максимума">Функция поиска минимума и максимума</h3>
<p>При поиске минимума и максимума результата два — классический пример, когда можно результаты функции передать не через возвращаемое значение, а через параметры. Типом выходных параметров не может быть <code>double</code>, потому что это тип <em>значений,</em> и параметры этого типа будут отдельными переменными, которые существуют в пределах функции, а следовательно, после ее вызова их нельзя будет считать. Остаются либо ссылки, либо указатели.</p>
<p>Если выбрать ссылки, их всегда придется передавать в функцию, изнутри которой они будут доступны без особого синтаксиса:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb5-2" title="2">find_minmax(vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>&amp; min, <span class="dt">double</span>&amp; max) {</a>
<a class="sourceLine" id="cb5-3" title="3">    min = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb5-5" title="5">}</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="dt">double</span> min, max;</a>
<a class="sourceLine" id="cb5-9" title="9">find_minmax(numbers, min, max);</a></code></pre></div>
<p>При использовании указателей их потребуется разыменовывать в функции, а при вызове нужно будет передавать не переменные, а их адреса:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb6-2" title="2">find_minmax(vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>* min, <span class="dt">double</span>* max) {</a>
<a class="sourceLine" id="cb6-3" title="3">    *min = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-5" title="5">}</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="dt">double</span> min, max;</a>
<a class="sourceLine" id="cb6-9" title="9">find_minmax(numbers, &amp;min, &amp;max);</a></code></pre></div>
<ol class="example" type="1">
<li>Выделите в программе функцию <code>find_minmax()</code> в любом варианте, добейтесь компиляции и корректной работы программы.</li>
</ol>
<h3 id="передача-по-константной-ссылке">Передача по константной ссылке</h3>
<p>Оптимально ли выбран тип входного параметра <code>numbers</code>? Во-первых, изменять его не требуется, он может быть константным. Во-вторых, поскольку он не объявлен ссылкой или указателем, это отдельная переменная, которая получает значением копию вектора, который передается в функцию. Однако копия не нужна. Итого выгоднее использовать константную ссылку: <code>const vector&lt;double&gt;&amp; numbers</code>.</p>
<ol start="2" class="example" type="1">
<li><p>Выделите поиск минимума и максимума в функцию <code>find_minmax()</code>. Типы всех парамтеров выберите на свое усмотрение.</p></li>
<li><p>Выделите расчет количества чисел в столбцах гистограммы в функцию <code>make_histogram()</code>.</p></li>
<li><p>Выделите отображение гистограммы в функцию <code>show_histogram_text()</code>.</p></li>
</ol>
<h2 id="декомпозиция-программы">Декомпозиция программы</h2>
<p>Итоговая функция <code>main()</code> принимает вид (за вычетом оформления):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">size_t</span> number_count;</a>
<a class="sourceLine" id="cb7-2" title="2">cin &gt;&gt; number_count;</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="at">const</span> <span class="kw">auto</span> numbers = input_numbers(number_count);</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">size_t</span> bin_count;</a>
<a class="sourceLine" id="cb7-5" title="5">cin &gt;&gt; bin_count;</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="at">const</span> <span class="kw">auto</span> bins = make_histogram(numbers, bin_count);</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">show_histogram_text(bins);</a></code></pre></div>
<p>Можно видеть, что функциями фактически выделены блоки ввода данных, обработки данных и вывода результатов. Ввод данных частично находится вне функции <code>input_numbers()</code>, потому что иначе она оказалась бы слишком специфичной, «заточенной» под программу. Функция же ввода массива может быть полезной во многих случаях.</p>
<p>Помимо выделения блоков кода, функции определяют взаимодействие между частями программы и скрывают реализацию этих частей. Через типы параметров функций и их возвращаемых значений фиксируется, какой информацией обмениваются части программы <em>(интерфейсы</em> этих частей, не путать с интерфейсом пользователя). При грамотной декомпозиции интерфейсы сохраняются (иногда дополняясь) при модернизации частей программы.</p>
<ol start="5" class="example" type="1">
<li>Добейтесь корректной работы программы и сделайте коммит.</li>
</ol>
<h1 id="часть-2.-вывод-гистограммы-как-изображения-в-формате-svg">Часть 2. Вывод гистограммы как изображения в формате SVG</h1>
<p>Изображения в формате SVG представляют собой текстовые файлы, в которых перечислены геометрические фигуры (линии, прямоугольники и прочие) и их свойства (положение, размер, цвет и другие). Кроме самих геометрических фигур, файл содержит заголовок и окончание.</p>
<p>Например, такой файл SVG описывает изображение размером 200×300 точек с линией из точки <em>(0, 0)</em> в точку <em>(100, 100)</em> синего цвета толщиной 4 точки:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">&lt;?xml</span> version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; <span class="kw">?&gt;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">&lt;svg</span><span class="ot"> width=</span><span class="st">&#39;200&#39;</span><span class="ot"> height=</span><span class="st">&#39;300&#39;</span><span class="ot"> viewBox=</span><span class="st">&#39;0 0 200 300&#39;</span><span class="ot"> xmlns=</span><span class="st">&#39;http://www.w3.org/2000/svg&#39;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">&lt;line</span><span class="ot"> x1=</span><span class="st">&#39;0&#39;</span><span class="ot"> y1=</span><span class="st">&#39;0&#39;</span><span class="ot"> x2=</span><span class="st">&#39;100&#39;</span><span class="ot"> y2=</span><span class="st">&#39;100&#39;</span><span class="ot"> stroke=</span><span class="st">&#39;blue&#39;</span><span class="ot"> stroke-width=</span><span class="st">&#39;4&#39;</span><span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">&lt;/svg&gt;</span></a></code></pre></div>
<p>Здесь строка <code>&lt;line... /&gt;</code> описывает линию. Выше нее находится заголовок файла, ниже нее — окончание файла.</p>
<p>Система координат SVG отличается от математической: ось Y направлена вниз, то есть точка <em>(0,0)</em> находится в верхнем левом углу. Координаты в SVG действительные, то есть может быть точка <em>(0.5, 3.14).</em></p>
<p>Кроме линий, SVG поддерживает множество элементов, среди них:</p>
<ul>
<li><code>&lt;text x="20" y="35"&gt;anything you want&lt;/text&gt;</code>: текст «anything you want», левый нижний угол которого в точке <em>(20,35);</em></li>
<li><code>&lt;rect x="0" y="0" width="100" height="200" /&gt;</code>: прямоугольник 100×200 с верхним левым углом в точке <em>(0,0)</em>.</li>
</ul>
<h2 id="задача">Задача</h2>
<p>Требуется переделать вывод гистограммы на формат SVG.</p>
<h2 id="указания-1">Указания</h2>
<p>С точки зрения SVG, гистограмма представляет собой элементы <code>&lt;text&gt;</code> с подписями столбцов и элементы <code>&lt;rect&gt;</code> напротив них — столбцы гистограммы.</p>
<p>Вывод отдельных элементов SVG (заголовка, окончания, текста, прямоугольника) стоит оформить в виде функций, который будут принимать параметры геометрии и печатать соответствующий текст. Весь вывод гистограммы в SVG реализуем в функции <code>show_histogram_svg()</code>, интерфейс которой не отличается от <code>show_historgam_text()</code>, вызов которой заменим вызовом новой функции.</p>
<p>Для проверки работы программы можно направлять ее стандартный вывод в файл с расширением SVG и просматривать его в браузере.</p>
<h3 id="вывод-заголовка-и-окончания-svg">Вывод заголовка и окончания SVG</h3>
<p>Отработаем цикл модификации и проверки программы на примере пустого изображения. Вот готовые функции вывода заголовка и окончания SVG:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb9-2" title="2">svg_begin(<span class="dt">double</span> width, <span class="dt">double</span> height) {</a>
<a class="sourceLine" id="cb9-3" title="3">    cout &lt;&lt; <span class="st">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb9-4" title="4">    cout &lt;&lt; <span class="st">&quot;&lt;svg width=&#39;&quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot;&#39; height=&#39;&quot;</span> &lt;&lt; height <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb9-5" title="5">         &lt;&lt; <span class="st">&quot;viewBox=&#39;0 0 &quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb9-6" title="6">         &lt;&lt; <span class="st">&quot;xmlns=&#39;http://www.w3.org/2000/svg&#39;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb9-7" title="7">}</a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="dt">void</span></a>
<a class="sourceLine" id="cb9-10" title="10">svg_end() {</a>
<a class="sourceLine" id="cb9-11" title="11">    cout &lt;&lt; <span class="st">&quot;&lt;/svg&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb9-12" title="12">}</a></code></pre></div>
<p>Обратите внимание на пробелы в строках, например, перед закрывающей кавычкой во фрагменте <code>"viewBox='0 0 "</code>. Также обратите внимание на использование одинарных кавычек. Двойные кавычки ограничивают в C++ строковые литералы; одинарные кавычки внутри них выводятся «как есть» в результирующую строку. Путаница кавычек или отсутствие некоторых пробелов сделает SVG некорректным.</p>
<p>Пусть начальная реализация графического вывода гистограммы всегда выводит пустое изображение фиксированного размера:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb10-2" title="2">show_histogram_svg(<span class="at">const</span> vector&lt;<span class="dt">size_t</span>&gt;&amp; bins) {</a>
<a class="sourceLine" id="cb10-3" title="3">    svg_begin(<span class="dv">400</span>, <span class="dv">300</span>);</a>
<a class="sourceLine" id="cb10-4" title="4">    svg_end();</a>
<a class="sourceLine" id="cb10-5" title="5">}</a></code></pre></div>
<p>Заменим вызов <code>show_histogram_text(bins)</code> вызовом <code>show_histogram_svg(bins)</code>.</p>
<p>Создать файл изображения можно так:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="ex">C</span>:\lab03-histogram<span class="op">&gt;</span> bin/Debug/lab03-histogram.exe <span class="op">&lt;</span>marks.txt <span class="op">&gt;</span>marks.svg</a></code></pre></div>
<p>В браузере <code>marks.svg</code> открывается из меню <em>Файл → Открыть…</em> Отобразится пустая страница (пустой рисунок). Можно нажать <em>Ctrl+U</em> или пункт <em>«Исходный код страницы»</em> в контекстном меню любого места страницы, чтобы увидеть результирующий код SVG.</p>
<h3 id="функции-вывода-элементов-svg">Функции вывода элементов SVG</h3>
<ol start="6" class="example" type="1">
<li><p>Напишите функцию для вывода текста в SVG, которая принимает координату по горизонтали (<code>left</code>), координату нижнего края текста по вертикали (<code>baseline</code>) и сам текст:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span> svg_text(<span class="dt">double</span> left, <span class="dt">double</span> baseline, string text);</a></code></pre></div></li>
</ol>
<p>Для проверки выведем высоту первого столбца гистограммы:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb13-2" title="2">show_histogram_svg(<span class="at">const</span> vector&lt;<span class="dt">size_t</span>&gt;&amp; bins) {</a>
<a class="sourceLine" id="cb13-3" title="3">    svg_begin(<span class="dv">400</span>, <span class="dv">300</span>);</a>
<a class="sourceLine" id="cb13-4" title="4">    svg_text(<span class="dv">20</span>, <span class="dv">20</span>, to_string(bins[<span class="dv">0</span>]));</a>
<a class="sourceLine" id="cb13-5" title="5">    svg_end();</a>
<a class="sourceLine" id="cb13-6" title="6">}</a></code></pre></div>
<p>Функция <code>to_string()</code> преобразует значения разных типов в строки.</p>
<p>Чтобы проверить модифицированную программу, её нужно запустить повторно:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1"><span class="ex">C</span>:\lab03-histogram<span class="op">&gt;</span> bin/Debug/lab03-histogram.exe <span class="op">&lt;</span>marks.txt <span class="op">&gt;</span>marks.svg</a></code></pre></div>
<p>После повторного запуска программы открытый в браузере файл можно обновить клавишей <em>F5.</em> На странице должен быть виден текст «2». Если в файле ошибка, он не отобразится. В этом случае нужно просмотреть код страницы на предмет ошибок в SVG, исправить код программы, перезапустить ее и проверить результат.</p>
<ol start="7" class="example" type="1">
<li><p>Напишите функцию для вывода прямоугольника в SVG:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height);</a></code></pre></div></li>
</ol>
<p>Для проверки выведем первый столбец гистограммы справа от подписи к нему:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">    svg_rect(<span class="dv">50</span>, <span class="dv">0</span>, bins[<span class="dv">0</span>] * <span class="dv">10</span>, <span class="dv">30</span>);</a></code></pre></div>
<ol start="8" class="example" type="1">
<li>Убедитесь, что вывод первого столбца гистограммы работает.</li>
</ol>
<h3 id="исключение-магических-констант">Исключение «магических констант»</h3>
<p>Текст выводится в координатах <em>(20, 20)</em>, смещение левого края столбца <em>50</em> (оно же — ширина подписей), а высота столбца <em>30.</em> Эти числа подобраны так, чтобы элементы гистограммы не накладывались друг на друга, но они разбросаны по коду и их смысл неясен.</p>
<p>Прямо внутри функции <code>show_histogram_svg()</code> заведем константы:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="at">const</span> <span class="kw">auto</span> IMAGE_WIDTH = <span class="dv">400</span>;</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="at">const</span> <span class="kw">auto</span> IMAGE_HEIGHT = <span class="dv">300</span>;</a>
<a class="sourceLine" id="cb17-3" title="3"><span class="at">const</span> <span class="kw">auto</span> TEXT_LEFT = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="at">const</span> <span class="kw">auto</span> TEXT_BASELINE = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="at">const</span> <span class="kw">auto</span> TEXT_WIDTH = <span class="dv">50</span>;</a>
<a class="sourceLine" id="cb17-6" title="6"><span class="at">const</span> <span class="kw">auto</span> BIN_HEIGHT = <span class="dv">30</span>;</a></code></pre></div>
<ol start="9" class="example" type="1">
<li>Замените «магические числа» константами и проверьте работу программы.</li>
</ol>
<h3 id="вывод-гистограммы">Вывод гистограммы</h3>
<p>Логика вывода гистограммы следующая: каждая корзина выводится так же, как первая, но к вертикальной координате добавляется смещение — высота столбца:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">double</span> top = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="cf">for</span> (<span class="dt">size_t</span> bin : bins) {</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="at">const</span> <span class="dt">double</span> bin_width = <span class="dv">10</span> * bin;</a>
<a class="sourceLine" id="cb18-4" title="4">    svg_text(TEXT_LEFT, top + TEXT_BASELINE, to_string(bin));</a>
<a class="sourceLine" id="cb18-5" title="5">    svg_rect(TEXT_WIDTH, top, bin_width, BIN_HEIGHT);</a>
<a class="sourceLine" id="cb18-6" title="6">}</a></code></pre></div>
<p>«Магическая константа» 10 пока сохраняется, потому что логика расчета ширины прямоугольника еще будет модифицироваться.</p>
<ol start="10" class="example" type="1">
<li>Реализуйте вывод гистограммы и проверьте работу программы.</li>
</ol>
<h3 id="оформление-гистограммы.-значения-параметров-по-умолчанию">Оформление гистограммы. Значения параметров по умолчанию</h3>
<p>Черная гистограмма не слишком эстетична или экономична при печати. За цвет линий в SVG отвечает атрибут <code>stroke</code>, а за цвет заливки — <code>fill</code>. Можно задать один из <a href="https://www.december.com/html/spec/colorsvghex.html">стандартных цветов</a> или выбрать цвет в формате <code>#RRGGBB</code> из <a href="http://getcolor.ru">палитры</a>. Пример прямоугольника с красными границами и бледно-розовой заливкой:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">&lt;rect</span><span class="ot"> x=</span><span class="st">&#39;50&#39;</span><span class="ot"> y=</span><span class="st">&#39;0&#39;</span><span class="ot"> width=</span><span class="st">&#39;30&#39;</span><span class="ot"> height=</span><span class="st">&#39;30&#39;</span><span class="ot"> stroke=</span><span class="st">&#39;red&#39;</span><span class="ot"> fill=</span><span class="st">&#39;#ffeeee&#39;</span><span class="kw">/&gt;</span></a></code></pre></div>
<ol start="11" class="example" type="1">
<li><p>Доработайте функцию <code>svg_rect()</code> для указания цвета линий и заливки:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb20-2" title="2">        string stroke, string fill);</a></code></pre></div></li>
<li><p>Измените цвета вывода и проверьте работу программы.</p></li>
</ol>
<h4 id="значения-параметров-по-умолчанию">Значения параметров по умолчанию</h4>
<p>Цвета элементов нужно задавать не всегда, а в текущей реализации у функции <code>svg_rect()</code> шесть параметров, два из которых отвечают за цвет. Можно было бы перегрузить функцию:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height);</a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb21-4" title="4">        string stroke, string fill);</a></code></pre></div>
<p>Однако в этом случае пришлось бы в каждой функции писать похожий код. В данном случае выгоднее применить значения параметров по умолчанию:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb22-2" title="2">        string stroke = <span class="st">&quot;black&quot;</span>, string fill = <span class="st">&quot;black&quot;</span>);</a></code></pre></div>
<p>Значения по умолчанию указываются только один раз, обычно в определении функции (если объявление и определение отделены). Новая версия <code>svg_rect()</code> работает так:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>);             <span class="co">// svg_rect(0, 0, 100, 200, &quot;black&quot;, &quot;black&quot;);</span></a>
<a class="sourceLine" id="cb23-2" title="2">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="st">&quot;red&quot;</span>);      <span class="co">// svg_rect(0, 0, 100, 200, &quot;red&quot;,   &quot;black&quot;);</span></a>
<a class="sourceLine" id="cb23-3" title="3">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="st">&quot;blue&quot;</span>, <span class="dv">4</span>);</a></code></pre></div>
<ol start="13" class="example" type="1">
<li>Добавьте значения параметров по умолчанию функции <code>svg_rect()</code>.</li>
</ol>
<h1 id="часть-3.-модульное-тестирование">Часть 3. Модульное тестирование</h1>
<p>Ранее для тестирования программы применялось перенаправление ввода и вывода. Такое тестирование называется функциональным. Однако функционального тестирования недостаточно для больших программ. Предположим, большая программа перестала выдавать правильный результат — как найти место ошибки? Необязательно это последнее изменение: возможно, другая часть и ранее работала неверно в некоторых случаях, и последняя правка лишь привела к такому случаю.</p>
<p>Модульное тестирование (unit testing) проверяет не работу всей программы, а работу отдельных ее компонент, например, отдельных функций. Модульные тесты пишутся программистами для собственного кода (функциональные тесты могут писаться или проводятся вручную другими специалистами).</p>
<p>Модульный тест — это отдельная программа, которая изолированно проверяет части кода основной программы. Если желательно протестировать части сложного алгоритма, эти части должны быть оформлены в виде отдельных функций (говорят: код должен быть <em>тестируемым).</em></p>
<h2 id="задача-1">Задача</h2>
<p>Написать модульный тест для функции поиска минимума и максимума.</p>
<h2 id="указания-2">Указания</h2>
<h3 id="выделение-тестируемой-функции-в-модуль">Выделение тестируемой функции в модуль</h3>
<p>Функция <code>find_minmax()</code> находится в основном (и единственном) модуле <code>main.cpp</code>. Для использования функции в других программах нужно вынести ее код в отдельный модуль. Модулем в практике C++ называется заголовочный файл (<code>*.h</code>) с объявлениями функций и файл реализации (<code>*.cpp</code>) с их определениями.</p>
<h4 id="создание-заголовочного-файла">Создание заголовочного файла</h4>
<ol start="14" class="example" type="1">
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту заголовочный файл <em>(C/C++ header).</em> Он должен быть расположен в каталоге проекта:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\histogram.h</code></p></li>
</ol>
<p>Заготовка файла включает «стража включения» (см. лекции):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="pp">#ifndef HISTOGRAM_H_INCLUDED</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="pp">#define H</span>ISTOGRAM_H_INCLUDED</a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="pp">#endif </span><span class="co">// HISTOGRAM_H_INCLUDED</span></a></code></pre></div>
<p>Можно заменить его на более простой вариант <code>#pragma once</code> или писать код в этом файле между <code>#define</code> и <code>#endif</code>.</p>
<ol start="15" class="example" type="1">
<li>Перенесите функцию <code>find_minmax()</code> в <code>histogram.h</code>.</li>
</ol>
<p>Помимо самой функции в начало <code>histogram.h</code> (под <code>#pragma once</code>) нужно добавить подключение библиотеки векторов и стандартного пространства имен:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> std;</a></code></pre></div>
<p>Если теперь попытаться собрать программу, это не удастся: в файле <code>main.cpp</code> функция <code>find_minmax()</code> теперь отсутствует. Необходимо подключить файл <code>histogram.h</code> (в самом начале файла <code>main.cpp</code>):</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a></code></pre></div>
<p>Обратите внимание на использование кавычек вместо угловых скобок: кавычки означают, что путь к файлу <code>*.h</code> написан относительно файла с <code>#include</code>, а угловые скобки предписывают искать включаемый файл по определенным в настройках путям.</p>
<ol start="16" class="example" type="1">
<li>Скомпилируйте программу и проверьте, что она работает.</li>
</ol>
<h4 id="создание-файла-реализации">Создание файла реализации</h4>
<ol start="17" class="example" type="1">
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту файл реализации <em>(C/C++ source).</em> Необходимые настройки:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\histogram.cpp</code><br />
<em>Add file to active project in build target(s)</em> — нажать <em>All.</em></p></li>
<li><p>В <code>histogram.cpp</code> подключите <code>histogram.h</code>.</p></li>
<li><p>Перенесите определение функции <code>find_minmax()</code> в <code>histogram.cpp</code>.</p></li>
<li><p>Оставьте в <code>histogram.h</code> от функции <code>find_minmax()</code> только объявление:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">void</span> find_minmax(<span class="at">const</span> vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>&amp; min, <span class="dt">double</span>&amp; max);</a></code></pre></div></li>
</ol>
<p>Если при выделении функции <code>find_minmax()</code> были использованы указатели, а не ссылки, объявление нужно соответствующим образом скорректировать.</p>
<ol start="21" class="example" type="1">
<li>Соберите программу и проверьте ее работу.</li>
</ol>
<h3 id="создание-проекта-для-модульных-тестов">Создание проекта для модульных тестов</h3>
<ol start="22" class="example" type="1">
<li><p>При помощи меню <em>File → New → Project…</em> создайте новый проект типа <em>Empty project.</em> Необходимые настройки:</p>
<p><em>Project title:</em> <code>lab03-test</code><br />
<em>Folder to create project in:</em> <code>C:\lab03-histogram</code><br />
<em>Project filename:</em> <code>lab03-test.cbp</code><br />
<em>Resulting filename:</em> <code>C:\lab03-histogram\lab03-test.cbp</code></p></li>
<li><p>Дважды щелкните по проекту <code>lab03-test</code>, чтобы сделать его активным.</p></li>
<li><p>Из контекстного меню проекта <code>lab03-test</code> выберите пункт <em>Add files…</em> и добавьте к проекту <code>histogram.h</code> и <code>histogram.cpp</code>. В открывшемся диалоге <em>Select the targets this file should belong to:</em> проставьте все флажки.</p></li>
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту <code>lab03-test</code> файл реализации <em>(C/C++ source).</em> Необходимые настройки:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\test.cpp</code><br />
<em>Add file to active project in build target(s)</em> — нажать <em>All.</em></p></li>
</ol>
<h3 id="написание-модульных-тестов">Написание модульных тестов</h3>
<p>Файл <code>test.cpp</code> представляет собой полноценную тестирующую программу, в которой подключен тестируемый модуль, библиотека с <code>assert()</code> (см. лекцию) и присутствует функция <code>main()</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></a>
<a class="sourceLine" id="cb28-4" title="4"></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb28-6" title="6">main() {</a>
<a class="sourceLine" id="cb28-7" title="7">}</a></code></pre></div>
<p>Первый тест будет проверять простой случай массива положительных чисел:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></a>
<a class="sourceLine" id="cb29-4" title="4"></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="dt">void</span></a>
<a class="sourceLine" id="cb29-6" title="6">test_positive() {</a>
<a class="sourceLine" id="cb29-7" title="7">    <span class="dt">double</span> min = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb29-8" title="8">    <span class="dt">double</span> max = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb29-9" title="9">    find_minmax({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}, min, max);</a>
<a class="sourceLine" id="cb29-10" title="10">    <span class="ot">assert</span>(min == <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb29-11" title="11">    <span class="ot">assert</span>(max == <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb29-12" title="12">}</a>
<a class="sourceLine" id="cb29-13" title="13"></a>
<a class="sourceLine" id="cb29-14" title="14"><span class="dt">int</span></a>
<a class="sourceLine" id="cb29-15" title="15">main() {</a>
<a class="sourceLine" id="cb29-16" title="16">    test_positive();</a>
<a class="sourceLine" id="cb29-17" title="17">}</a></code></pre></div>
<ol start="26" class="example" type="1">
<li><p>Соберите программу-тест, запустите ее и убедитесь, что она завершается без ошибок, то есть тест проходит.</p></li>
<li><p>Замените проверку <code>max == 3</code> на <code>max == 4</code>. Соберите и запустите программу, чтобы наблюдать образец вывода при провале теста. Верните правильную проверку.</p></li>
<li><p>Добавьте новые тесты (имена придумайте) на такие случаи:</p>
<ul>
<li>массив из трех отрицательных чисел;</li>
<li>массив из трех одинаковых чисел;</li>
<li>массив из одного числа.</li>
</ul>
<p>Убедитесь, что все тесты проходят.</p></li>
<li><p>Добавьте тест на обработку пустого массива и проверьте, проходит ли он.</p></li>
</ol>
<p>Если <code>find_minmax()</code> в своем начале обращается к <code>numbers[0]</code>, программа будет завершаться аварийно, так как для пустого массива <code>numbers[0]</code> нет.</p>
<p>Обратите внимание: тщательное написание модульных тестов позволило выявить случай, при котором код не работает. Выходом может быть такое поведение: в начале <code>find_minmax()</code> проверять длину массива (<code>numbers.size()</code>), и если она нулевая, возвращаться из функции без изменения <code>min</code> и <code>max</code>. Тест тогда может проверять, что в результате вызова <code>min</code> и <code>max</code> не меняются. Возможно, стоит также учесть случай пустого массива в основной программе.</p>
<ol start="30" class="example" type="1">
<li>Внесите исправления в <code>histogram.cpp</code> (как минимум), пересоберите основную программу и тест, убедитесь, что они работают.</li>
</ol>
<h1 id="часть-4.-использование-структур-перечислений-и-операторов">Часть 4. Использование структур, перечислений и операторов</h1>
<h2 id="задача-2">Задача</h2>
<p>Необходимо отображать конструкцию, изображенную на рисунке, при любых значениях углов поворота каждого из звеньев:</p>
<p><img src="example.svg" /></p>
<p>Все звенья имеют одинаковую длину 100, при нулевом угле поворота расположены горизонтально. Программа должна быть расширяемой, то есть ее должно быть легко доработать под появление новых звеньев. На ввод подаются углы поворота в градусах, выводиться должен рисунок в SVG.</p>
<h2 id="указания-3">Указания</h2>
<h3 id="план-решения">План решения</h3>
<p><strong>Ввод</strong> трех действительных углов не представляет трудностей.</p>
<p><strong>Обработка данных —</strong> преобразования координат методами линейной алгебры. Следовательно, в программе потребуется оперировать двумерными точками и двумерными векторами. На вход обработки подаются звенья-отрезки в своем начальном положении, на выходе — отрезки с рассчитанными координатами после поворотов.</p>
<p><strong>Вывод данных</strong> потребует написания новой функции <code>svg_line()</code> для вывода линии; эта функция аналогична <code>svg_rect()</code>.</p>
<p>Имеется вопрос стыковки части обработки данных и вывода: система координат SVG отличается от системы координат, принятой в линейной алгебре. Различие можно убрать средствами SVG (далее будет показано, как).</p>
<h3 id="section">…</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">struct</span> Point {</a>
<a class="sourceLine" id="cb30-2" title="2">    <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb30-3" title="3">    <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb30-4" title="4">};</a>
<a class="sourceLine" id="cb30-5" title="5"></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="kw">struct</span> Line {</a>
<a class="sourceLine" id="cb30-7" title="7">    Point begin;</a>
<a class="sourceLine" id="cb30-8" title="8">    Point end;</a>
<a class="sourceLine" id="cb30-9" title="9">};</a>
<a class="sourceLine" id="cb30-10" title="10"></a>
<a class="sourceLine" id="cb30-11" title="11">Vec2 AB{<span class="dv">100</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb30-12" title="12">Vec2 BC{<span class="dv">100</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb30-13" title="13">Vec2 CD{<span class="dv">100</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb30-14" title="14">Vec2 DE = rotate({<span class="dv">20</span>, <span class="dv">20</span>},  <span class="dv">40</span>);</a>
<a class="sourceLine" id="cb30-15" title="15">Vec2 EF = rotate({<span class="dv">20</span>, <span class="dv">20</span>}, -<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb30-16" title="16">Vec2 DG = EF;</a>
<a class="sourceLine" id="cb30-17" title="17">Vec2 GH = DE;</a>
<a class="sourceLine" id="cb30-18" title="18"></a>
<a class="sourceLine" id="cb30-19" title="19">Point A{<span class="dv">0</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb30-20" title="20">Point B = A + rotate(AB, alpha);</a>
<a class="sourceLine" id="cb30-21" title="21">Point C = B + rotate(BC, beta);</a>
<a class="sourceLine" id="cb30-22" title="22">Point D = C + rotate(CD, gamma);</a>
<a class="sourceLine" id="cb30-23" title="23">Point E = rotate(CD + DE, gamma);</a>
<a class="sourceLine" id="cb30-24" title="24">Point F = rotate(CD + DE + EF, gamma);</a>
<a class="sourceLine" id="cb30-25" title="25">Point G = rotate(CD + DG, gamma);</a>
<a class="sourceLine" id="cb30-26" title="26">Point H = rotate(CD + DG + GH, gamma);</a>
<a class="sourceLine" id="cb30-27" title="27"></a>
<a class="sourceLine" id="cb30-28" title="28">Line link1{A, B};</a>
<a class="sourceLine" id="cb30-29" title="29">Line link2{B, C};</a>
<a class="sourceLine" id="cb30-30" title="30">Line link3{C, D};</a>
<a class="sourceLine" id="cb30-31" title="31"><span class="co">// </span><span class="al">TODO</span><span class="co">: hand</span></a></code></pre></div>
<hr />
<h1 id="введение">Введение</h1>
<h1 id="постановка-задачи">Постановка задачи</h1>
<p>Имеется манипулятор (механическая «рука») из трех звеньев и захвата:</p>
<p>TODO: рисунок</p>
<p>Размеры манипулятора и его начальное положение известны. Задаются углы поворота каждого звена <code>alpha</code>, <code>beta</code>, <code>gamma</code> и угол <code>theta</code>, на который раскрыт захват.</p>
<p>Необходимо:</p>
<ol type="1">
<li>Рассчитать положение всех частей манипулятора.</li>
<li>Изобразить чертеж манипулятора в заданном положении.</li>
</ol>
<p>Программу нужно написать качественно: в дальнейшем предполагается добавить новые виды манипуляторов и их движений.</p>
<h1 id="план-решения-1">План решения</h1>
<p><strong>Ввод данных:</strong></p>
<ul>
<li>размеры манипулятора и начальное положение звеньев можно задать константами;</li>
<li>углы вводятся как действительные числа.</li>
</ul>
<p><strong>Обработка данных</strong> состоит в вычислении координат всех отрезков методами, известными из линейной алгебры и теоретической механики.</p>
<p><strong>Вывод данных</strong> предлагается делать в формате SVG, поскольку он позволяет изобразить отрезки путем вывода их координат как текста в определенном формате.</p>
<p>Поскольку имеется начальное положение всех отрезков, предлагается сначала реализовать вывод данных, а только после — обработку.</p>
<h1 id="ввод-данных">Ввод данных</h1>
<pre><code>A
B = A + M1 * L1
C = B + M2 * L2
D = C + M3 * L3
E1 = C + M4 * H11
F1 = E1 + M4 * H12
E2 = C + M5 * H21
F2 = E2 + M5 * H22</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">struct</span> Vec2 {</a>
<a class="sourceLine" id="cb32-2" title="2">    <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb32-3" title="3">    <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb32-4" title="4">};</a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="kw">struct</span> Mat22 {</a>
<a class="sourceLine" id="cb32-7" title="7">    <span class="dt">double</span> a[<span class="dv">2</span>][<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb32-8" title="8">};</a>
<a class="sourceLine" id="cb32-9" title="9"></a>
<a class="sourceLine" id="cb32-10" title="10">Vec2 add(Vec2 a, Vec2 b) {</a>
<a class="sourceLine" id="cb32-11" title="11">    <span class="cf">return</span> {a.x + b.y, a.y + b.y};</a>
<a class="sourceLine" id="cb32-12" title="12">}</a>
<a class="sourceLine" id="cb32-13" title="13"></a>
<a class="sourceLine" id="cb32-14" title="14">Vec2 multiply(Mat22 m, Vec2 v) {</a>
<a class="sourceLine" id="cb32-15" title="15">    <span class="cf">return</span> {</a>
<a class="sourceLine" id="cb32-16" title="16">            v.x * m.a[<span class="dv">0</span>][<span class="dv">0</span>] + v.y * m.a[<span class="dv">0</span>][<span class="dv">1</span>],</a>
<a class="sourceLine" id="cb32-17" title="17">            v.x * m.a[<span class="dv">1</span>][<span class="dv">0</span>] + v.y * m.a[<span class="dv">1</span>][<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb32-18" title="18">    };</a>
<a class="sourceLine" id="cb32-19" title="19">}</a>
<a class="sourceLine" id="cb32-20" title="20"></a>
<a class="sourceLine" id="cb32-21" title="21">Mat22 rotation(<span class="dt">double</span> angle_degrees) {</a>
<a class="sourceLine" id="cb32-22" title="22">    <span class="at">const</span> <span class="dt">double</span> alpha = M_PI * angle_degrees / <span class="dv">180</span>;</a>
<a class="sourceLine" id="cb32-23" title="23">    <span class="at">const</span> <span class="dt">double</span> sin_a = sin(alpha);</a>
<a class="sourceLine" id="cb32-24" title="24">    <span class="at">const</span> <span class="dt">double</span> cos_a = cos(alpha);</a>
<a class="sourceLine" id="cb32-25" title="25">    <span class="cf">return</span> {</a>
<a class="sourceLine" id="cb32-26" title="26">            { cos_a, sin_a},</a>
<a class="sourceLine" id="cb32-27" title="27">            {-sin_a, cos_a}</a>
<a class="sourceLine" id="cb32-28" title="28">    };</a>
<a class="sourceLine" id="cb32-29" title="29">}</a>
<a class="sourceLine" id="cb32-30" title="30"></a>
<a class="sourceLine" id="cb32-31" title="31">Vec2 s1 = Vec2(<span class="dv">0</span>, <span class="dv">100</span>);</a>
<a class="sourceLine" id="cb32-32" title="32">Vec2 s2 = rotation(<span class="dv">45</span>) * Vec2(<span class="dv">100</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb32-33" title="33">Vec2 s3 = Vec2(<span class="dv">100</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb32-34" title="34">Vec2 h11 = rotation(<span class="dv">45</span>) * Vec2(<span class="dv">0</span>, <span class="dv">50</span>);</a>
<a class="sourceLine" id="cb32-35" title="35">Vec2 h12 = rotation(-<span class="dv">45</span>) * Vec2(<span class="dv">0</span>, <span class="dv">50</span>);</a>
<a class="sourceLine" id="cb32-36" title="36">Vec2 h21 = h12;</a>
<a class="sourceLine" id="cb32-37" title="37">Vec2 h22 = h11;</a>
<a class="sourceLine" id="cb32-38" title="38"></a>
<a class="sourceLine" id="cb32-39" title="39"><span class="co">// later</span></a>
<a class="sourceLine" id="cb32-40" title="40">s1 = rotation(alpha) * s1;</a>
<a class="sourceLine" id="cb32-41" title="41">s2 = rotation(beta) * s2;</a>
<a class="sourceLine" id="cb32-42" title="42">s2 = rotation(gamma) * s2;</a>
<a class="sourceLine" id="cb32-43" title="43">Mat22 m4 = rotation(theta / <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb32-44" title="44">Mat22 m5 = rotation(-theta / <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb32-45" title="45">h11 = m4 * h11;</a>
<a class="sourceLine" id="cb32-46" title="46">h12 = m4 * h12;</a>
<a class="sourceLine" id="cb32-47" title="47">h21 = m4 * h21;</a>
<a class="sourceLine" id="cb32-48" title="48">h22 = m4 * h22;</a>
<a class="sourceLine" id="cb32-49" title="49"></a>
<a class="sourceLine" id="cb32-50" title="50">Vec2 a{<span class="dv">0</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb32-51" title="51">Vec2 b = add(a, s1);</a>
<a class="sourceLine" id="cb32-52" title="52">Vec2 c = add(b, s2);</a>
<a class="sourceLine" id="cb32-53" title="53">Vec2 d = add(c, s3);</a>
<a class="sourceLine" id="cb32-54" title="54">Vec2 e1 = add(d, h11);</a>
<a class="sourceLine" id="cb32-55" title="55">Vec2 f1 = add(e1, h12);</a>
<a class="sourceLine" id="cb32-56" title="56">Vec2 e2 = add(d, h21);</a>
<a class="sourceLine" id="cb32-57" title="57">Vec2 f2 = add(e2, h22);</a>
<a class="sourceLine" id="cb32-58" title="58"></a>
<a class="sourceLine" id="cb32-59" title="59">svg_begin(<span class="dv">400</span>, <span class="dv">400</span>);</a>
<a class="sourceLine" id="cb32-60" title="60">svg_line(a, b, <span class="st">&quot;red&quot;</span>);</a>
<a class="sourceLine" id="cb32-61" title="61">svg_line(b, c, <span class="st">&quot;green&quot;</span>);</a>
<a class="sourceLine" id="cb32-62" title="62">svg_line(c, d, <span class="st">&quot;blue&quot;</span>);</a>
<a class="sourceLine" id="cb32-63" title="63">svg_line(d, e1, <span class="st">&quot;orange&quot;</span>);</a>
<a class="sourceLine" id="cb32-64" title="64">svg_line(e1, f1, <span class="st">&quot;lime&quot;</span>);</a>
<a class="sourceLine" id="cb32-65" title="65">svg_line(d, e2, <span class="st">&quot;cyan&quot;</span>);</a>
<a class="sourceLine" id="cb32-66" title="66">svg_line(e2, f2, <span class="st">&quot;magenta&quot;</span>);</a>
<a class="sourceLine" id="cb32-67" title="67">svg_end();</a>
<a class="sourceLine" id="cb32-68" title="68"></a>
<a class="sourceLine" id="cb32-69" title="69">Vec2 u{<span class="dv">50</span>, <span class="dv">70</span>};</a>
<a class="sourceLine" id="cb32-70" title="70">Vec2 v{<span class="dv">250</span>, <span class="dv">230</span>};</a>
<a class="sourceLine" id="cb32-71" title="71"></a>
<a class="sourceLine" id="cb32-72" title="72"><span class="dt">void</span> svg_line(Vec2 a, Vec2 b, string color) {</a>
<a class="sourceLine" id="cb32-73" title="73">    cout &lt;&lt; <span class="st">&quot;&lt;line x1=&#39;&quot;</span> &lt;&lt; a.x &lt;&lt; <span class="st">&quot;&#39; y1=&#39;&quot;</span> &lt;&lt; a.y &lt;&lt; <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb32-74" title="74">         &lt;&lt; <span class="st">&quot;x2=&#39;&quot;</span> &lt;&lt; b.x &lt;&lt; <span class="st">&quot;&#39; y2=&#39;&quot;</span> &lt;&lt; b.y <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb32-75" title="75">         &lt;&lt; <span class="st">&quot;stroke=&#39;&quot;</span> &lt;&lt; color &lt;&lt; <span class="st">&quot;&#39; stroke-width=&#39;4&#39; /&gt;&quot;</span></a>
<a class="sourceLine" id="cb32-76" title="76">         &lt;&lt; endl;</a>
<a class="sourceLine" id="cb32-77" title="77">}</a>
<a class="sourceLine" id="cb32-78" title="78"></a>
<a class="sourceLine" id="cb32-79" title="79"><span class="dt">void</span> svg_begin(<span class="dt">size_t</span> width, <span class="dt">size_t</span> height) {</a>
<a class="sourceLine" id="cb32-80" title="80">    cout &lt;&lt; <span class="st">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&gt;</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb32-81" title="81">         &lt;&lt; <span class="st">&quot;&lt;svg width=&#39;&quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot;&#39; height=&#39;&quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb32-82" title="82">         &lt;&lt; <span class="st">&quot;viewBox=&#39;0 0 &quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; height <span class="st">&quot;&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb32-83" title="83">         &lt;&lt; <span class="st">&quot;&lt;g transform=&#39;translate(0,&quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;)&#39;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb32-84" title="84">         &lt;&lt; <span class="st">&quot;&lt;g transform=&#39;scale(1,-1)&#39;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb32-85" title="85">}</a>
<a class="sourceLine" id="cb32-86" title="86"></a>
<a class="sourceLine" id="cb32-87" title="87"><span class="dt">void</span> svg_end() {</a>
<a class="sourceLine" id="cb32-88" title="88">    cout &lt;&lt; <span class="st">&quot;&lt;/g&gt;</span><span class="sc">\n</span><span class="st">&quot;</span> &lt;&lt; <span class="st">&quot;&lt;/g&gt;</span><span class="sc">\n</span><span class="st">&quot;</span> &lt;&lt; <span class="st">&quot;&lt;/svg&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb32-89" title="89">}</a></code></pre></div>
    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А., Мохов&nbsp;А.&nbsp;С., Василькова&nbsp;П.&nbsp;Д. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2019&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="/study/courses/assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="/study/courses/assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
