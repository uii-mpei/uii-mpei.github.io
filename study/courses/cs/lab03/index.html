<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>РПОСУ. ЛР № 3. Функции и структуры</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div>
    <a href="http://uii.mpei.ru">Сайт кафедры</a> →
    <a href="/study/courses">Дисциплины ИТ</a> →
    <a href="/study/courses/cs">РПОСУ</a>
</div>
<header id="title-block-header">
<h1 class="title">РПОСУ. ЛР № 3. Функции и структуры</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#цель-работы">Цель работы</a></li>
<li><a href="#часть-1.-декомпозиция-программы-функциями">Часть 1. Декомпозиция программы функциями</a><ul>
<li><a href="#задание">Задание</a></li>
<li><a href="#указания">Указания</a><ul>
<li><a href="#функция-ввода-чисел">Функция ввода чисел</a></li>
<li><a href="#вывод-типов-переменных">Вывод типов переменных</a></li>
<li><a href="#функция-поиска-минимума-и-максимума">Функция поиска минимума и максимума</a></li>
<li><a href="#передача-по-константной-ссылке">Передача по константной ссылке</a></li>
</ul></li>
<li><a href="#декомпозиция-программы">Декомпозиция программы</a></li>
</ul></li>
<li><a href="#часть-2.-вывод-гистограммы-как-изображения-в-формате-svg">Часть 2. Вывод гистограммы как изображения в формате SVG</a><ul>
<li><a href="#задача">Задача</a></li>
<li><a href="#указания-1">Указания</a><ul>
<li><a href="#вывод-заголовка-и-окончания-svg">Вывод заголовка и окончания SVG</a></li>
<li><a href="#функции-вывода-элементов-svg">Функции вывода элементов SVG</a></li>
<li><a href="#исключение-магических-констант">Исключение «магических констант»</a></li>
<li><a href="#вывод-гистограммы">Вывод гистограммы</a></li>
<li><a href="#оформление-гистограммы.-значения-параметров-по-умолчанию">Оформление гистограммы. Значения параметров по умолчанию</a></li>
</ul></li>
</ul></li>
<li><a href="#часть-3.-модульное-тестирование">Часть 3. Модульное тестирование</a><ul>
<li><a href="#задача-1">Задача</a></li>
<li><a href="#указания-2">Указания</a><ul>
<li><a href="#выделение-тестируемой-функции-в-модуль">Выделение тестируемой функции в модуль</a></li>
<li><a href="#создание-проекта-для-модульных-тестов">Создание проекта для модульных тестов</a></li>
<li><a href="#написание-модульных-тестов">Написание модульных тестов</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<hr />
<h1 id="цель-работы">Цель работы</h1>
<ol type="1">
<li>Уметь структурировать программу при помощи функций и структур.</li>
<li>Уметь писать модульные тесты.</li>
</ol>
<h1 id="часть-1.-декомпозиция-программы-функциями">Часть 1. Декомпозиция программы функциями</h1>
<h2 id="задание">Задание</h2>
<p>Программа для построения гистограммы из ЛР № 1 состоит из одной функции <code>main()</code> на более чем 100 строк, из-за чего в ней неудобно ориентироваться. Необходимо выделить части программы в функции:</p>
<ul>
<li>Ввод чисел:
<ul>
<li>принимает количество чисел, которое необходимо ввести;</li>
<li>возвращает вектор чисел.</li>
</ul></li>
<li>Поиск наибольшего и наименьшего значения:
<ul>
<li>принимает вектор чисел;</li>
<li>возвращает два результата — min и max.</li>
</ul></li>
<li>Расчет гистограммы:
<ul>
<li>принимает вектор чисел и количество корзин;</li>
<li>возвращает вектор количеств чисел в каждой корзине;</li>
<li><em>вызывает</em> в процессе работы функцию поиска min и max.</li>
</ul></li>
</ul>
<p>При отсутствии решения ЛР № 1 его можно взять <a href="https://github.com/PlushBeaver/cs19-lab01">здесь</a>.</p>
<h2 id="указания">Указания</h2>
<h3 id="функция-ввода-чисел">Функция ввода чисел</h3>
<p>Сколько параметров у функции? Один — количество вводимых чисел. Сколько и каких значений функция возвращает? Одно значение — вектор из действительных чисел. Что функция позволяет <em>сделать?</em> Ввести числа (input numbers). Таким образом, функция имеет вид:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">vector&lt;<span class="dt">double</span>&gt;</a>
<a class="sourceLine" id="cb1-2" title="2">input_numbers(<span class="dt">size_t</span> count) {</a>
<a class="sourceLine" id="cb1-3" title="3">    vector&lt;<span class="dt">double</span>&gt; result(count);</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; count; i++) {</a>
<a class="sourceLine" id="cb1-5" title="5">        cin &gt;&gt; result[i];</a>
<a class="sourceLine" id="cb1-6" title="6">    }</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>Современный C++ (C++11 и выше) позволяет просто возвращать из функции вектор, и это будет работать эффективно, каков бы ни был его размер.</p>
<p>В основной программе (в функции <code>main()</code>) ввод чисел заменяется вызовом новой функции:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">size_t</span> number_count;</a>
<a class="sourceLine" id="cb2-2" title="2">cin &gt;&gt; number_count;</a>
<a class="sourceLine" id="cb2-3" title="3">vector&lt;<span class="dt">double</span>&gt; numbers = input_numbers(number_count);</a></code></pre></div>
<h3 id="вывод-типов-переменных">Вывод типов переменных</h3>
<p>Выбран ли тип переменной <code>numbers</code> наилучшим образом?</p>
<p>Можно заметить, что в дальнейшем <code>numbers</code> не изменяется, следовательно, можно сделать ее константной:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="at">const</span> vector&lt;<span class="dt">double</span>&gt; numbers = input_numbers(number_count);</a></code></pre></div>
<p>Теперь тип <code>numbers</code> занимает половину строки, что может быть неудобно читать. Можно заметить, что тип <code>numbers</code> обязан совпадать с типом возвращаемого значения функции <code>input_numbers()</code>, то есть избыточен. В современном С++ есть способ указать компилятору <em>вывести</em> тип переменной <code>numbers</code> из выражения, которое ей присваивается:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="at">const</span> <span class="kw">auto</span> numbers = input_numbers(number_count);</a></code></pre></div>
<p><strong>Ключевое слово <code>auto</code> не вводит новый тип.</strong> Переменная <code>numbers</code> по-прежнему является <code>const vector&lt;double&gt;</code>, просто это записано короче, так как компилятору это известно без явного указания. Стала ли программа более читаемой? Ответ неоднозначен. Код сократился, но теперь из него не очевидно (человеку), каков тип <code>numbers</code>; с другой стороны, читателю может и не быть важно, как представлены <code>numbers</code> — достаточно того, что там числа (это ясно из названия функции). Вывод: использовать <code>auto</code> следует там, где это сокращает код без сокрытия важных подробностей.</p>
<h3 id="функция-поиска-минимума-и-максимума">Функция поиска минимума и максимума</h3>
<p>При поиске минимума и максимума результата два — классический пример, когда можно результаты функции передать не через возвращаемое значение, а через параметры. Типом выходных параметров не может быть <code>double</code>, потому что это тип <em>значений,</em> и параметры этого типа будут отдельными переменными, которые существуют в пределах функции, а следовательно, после ее вызова их нельзя будет считать. Остаются либо ссылки, либо указатели.</p>
<p>Если выбрать ссылки, их всегда придется передавать в функцию, изнутри которой они будут доступны без особого синтаксиса:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb5-2" title="2">find_minmax(vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>&amp; min, <span class="dt">double</span>&amp; max) {</a>
<a class="sourceLine" id="cb5-3" title="3">    min = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb5-5" title="5">}</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="dt">double</span> min, max;</a>
<a class="sourceLine" id="cb5-9" title="9">find_minmax(numbers, min, max);</a></code></pre></div>
<p>При использовании указателей их потребуется разыменовывать в функции, а при вызове нужно будет передавать не переменные, а их адреса:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb6-2" title="2">find_minmax(vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>* min, <span class="dt">double</span>* max) {</a>
<a class="sourceLine" id="cb6-3" title="3">    *min = numbers[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-5" title="5">}</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="dt">double</span> min, max;</a>
<a class="sourceLine" id="cb6-9" title="9">find_minmax(numbers, &amp;min, &amp;max);</a></code></pre></div>
<ol class="example" type="1">
<li>Выделите в программе функцию <code>find_minmax()</code> в любом варианте, добейтесь компиляции и корректной работы программы.</li>
</ol>
<h3 id="передача-по-константной-ссылке">Передача по константной ссылке</h3>
<p>Оптимально ли выбран тип входного параметра <code>numbers</code>? Во-первых, изменять его не требуется, он может быть константным. Во-вторых, поскольку он не объявлен ссылкой или указателем, это отдельная переменная, которая получает значением копию вектора, который передается в функцию. Однако копия не нужна. Итого выгоднее использовать константную ссылку: <code>const vector&lt;double&gt;&amp; numbers</code>.</p>
<ol start="2" class="example" type="1">
<li><p>Выделите поиск минимума и максимума в функцию <code>find_minmax()</code>. Типы всех парамтеров выберите на свое усмотрение.</p></li>
<li><p>Выделите расчет количества чисел в столбцах гистограммы в функцию <code>make_histogram()</code>.</p></li>
<li><p>Выделите отображение гистограммы в функцию <code>show_histogram_text()</code>.</p></li>
</ol>
<h2 id="декомпозиция-программы">Декомпозиция программы</h2>
<p>Итоговая функция <code>main()</code> принимает вид (за вычетом оформления):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">size_t</span> number_count;</a>
<a class="sourceLine" id="cb7-2" title="2">cin &gt;&gt; number_count;</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="at">const</span> <span class="kw">auto</span> numbers = input_numbers(number_count);</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">size_t</span> bin_count;</a>
<a class="sourceLine" id="cb7-5" title="5">cin &gt;&gt; bin_count;</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="at">const</span> <span class="kw">auto</span> bins = make_histogram(numbers, bin_count);</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">show_histogram_text(bins);</a></code></pre></div>
<p>Можно видеть, что функциями фактически выделены блоки ввода данных, обработки данных и вывода результатов. Ввод данных частично находится вне функции <code>input_numbers()</code>, потому что иначе она оказалась бы слишком специфичной, «заточенной» под программу. Функция же ввода массива может быть полезной во многих случаях.</p>
<p>Помимо выделения блоков кода, функции определяют взаимодействие между частями программы и скрывают реализацию этих частей. Через типы параметров функций и их возвращаемых значений фиксируется, какой информацией обмениваются части программы <em>(интерфейсы</em> этих частей, не путать с интерфейсом пользователя). При грамотной декомпозиции интерфейсы сохраняются (иногда дополняясь) при модернизации частей программы.</p>
<ol start="5" class="example" type="1">
<li><p>Добейтесь корректной работы программы.</p></li>
<li><p>Сделайте коммит с текущим состоянием проекта и отправьте его на GitHub.</p></li>
</ol>
<p>Если вы клонировали авторское решение ЛР № 1, изменить адрес репозитария на собственный можно такой командой (с правильным адресом):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">git</span> remote set-url origin https://github.com/<span class="op">&lt;</span>username<span class="op">&gt;</span>/<span class="op">&lt;</span>repo<span class="op">&gt;</span>.git</a></code></pre></div>
<h1 id="часть-2.-вывод-гистограммы-как-изображения-в-формате-svg">Часть 2. Вывод гистограммы как изображения в формате SVG</h1>
<p>Изображения в формате SVG представляют собой текстовые файлы, в которых перечислены геометрические фигуры (линии, прямоугольники и прочие) и их свойства (положение, размер, цвет и другие). Кроме самих геометрических фигур, файл содержит заголовок и окончание.</p>
<p>Например, <a href="example.svg">такой файл SVG</a> описывает изображение размером 200×300 точек с линией из точки <em>(0, 0)</em> в точку <em>(100, 100)</em> синего цвета толщиной 4 точки:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">&lt;?xml</span> version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; <span class="kw">?&gt;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">&lt;svg</span><span class="ot"> width=</span><span class="st">&#39;200&#39;</span><span class="ot"> height=</span><span class="st">&#39;300&#39;</span><span class="ot"> viewBox=</span><span class="st">&#39;0 0 200 300&#39;</span><span class="ot"> xmlns=</span><span class="st">&#39;http://www.w3.org/2000/svg&#39;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">&lt;line</span><span class="ot"> x1=</span><span class="st">&#39;0&#39;</span><span class="ot"> y1=</span><span class="st">&#39;0&#39;</span><span class="ot"> x2=</span><span class="st">&#39;100&#39;</span><span class="ot"> y2=</span><span class="st">&#39;100&#39;</span><span class="ot"> stroke=</span><span class="st">&#39;blue&#39;</span><span class="ot"> stroke-width=</span><span class="st">&#39;4&#39;</span><span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">&lt;/svg&gt;</span></a></code></pre></div>
<p>Здесь строка <code>&lt;line... /&gt;</code> описывает линию. Выше нее находится заголовок файла, ниже нее — окончание файла.</p>
<p>Система координат SVG отличается от математической: ось Y направлена вниз, то есть точка <em>(0,0)</em> находится в верхнем левом углу. Координаты в SVG действительные, то есть может быть точка <em>(0.5, 3.14).</em></p>
<p>Фрагменты вида <code>&lt;svg&gt;</code> или <code>&lt;line&gt;</code> называются <em>элементами,</em> или <em>тэгами.</em> Параметры вида <code>height='300'</code> называются <em>атрибутами</em> элементов. Подробнее об SVG можно прочитать <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element">здесь</a>.</p>
<p>Кроме линий, SVG поддерживает множество элементов, среди них:</p>
<ul>
<li><code>&lt;text x='20' y='35'&gt;anything you want&lt;/text&gt;</code>: текст «anything you want», левый нижний угол которого в точке <em>(20,35);</em></li>
<li><code>&lt;rect x='0' y='0' width='100' height='200' /&gt;</code>: прямоугольник 100×200 с верхним левым углом в точке <em>(0,0)</em>.</li>
</ul>
<h2 id="задача">Задача</h2>
<p>Требуется переделать вывод гистограммы на формат SVG.</p>
<h2 id="указания-1">Указания</h2>
<p>С точки зрения SVG, гистограмма представляет собой элементы <code>&lt;text&gt;</code> с подписями столбцов и элементы <code>&lt;rect&gt;</code> напротив них — столбцы гистограммы.</p>
<p>Вывод отдельных элементов SVG (заголовка, окончания, текста, прямоугольника) стоит оформить в виде функций, который будут принимать параметры геометрии и печатать соответствующий текст. Весь вывод гистограммы в SVG реализуем в функции <code>show_histogram_svg()</code>, интерфейс которой не отличается от <code>show_historgam_text()</code>, вызов которой заменим вызовом новой функции.</p>
<p>Для проверки работы программы можно направлять ее стандартный вывод в файл с расширением SVG и просматривать его в браузере.</p>
<h3 id="вывод-заголовка-и-окончания-svg">Вывод заголовка и окончания SVG</h3>
<p>Отработаем цикл модификации и проверки программы на примере пустого изображения. Вот готовые функции вывода заголовка и окончания SVG:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb10-2" title="2">svg_begin(<span class="dt">double</span> width, <span class="dt">double</span> height) {</a>
<a class="sourceLine" id="cb10-3" title="3">    cout &lt;&lt; <span class="st">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb10-4" title="4">    cout &lt;&lt; <span class="st">&quot;&lt;svg width=&#39;&quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot;&#39; height=&#39;&quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb10-5" title="5">         &lt;&lt; <span class="st">&quot;viewBox=&#39;0 0 &quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;&#39; &quot;</span></a>
<a class="sourceLine" id="cb10-6" title="6">         &lt;&lt; <span class="st">&quot;xmlns=&#39;http://www.w3.org/2000/svg&#39;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb10-7" title="7">}</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="dt">void</span></a>
<a class="sourceLine" id="cb10-10" title="10">svg_end() {</a>
<a class="sourceLine" id="cb10-11" title="11">    cout &lt;&lt; <span class="st">&quot;&lt;/svg&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb10-12" title="12">}</a></code></pre></div>
<p>Обратите внимание на пробелы в строках, например, перед закрывающей кавычкой во фрагменте <code>"viewBox='0 0 "</code>. Также обратите внимание на использование одинарных кавычек. Двойные кавычки ограничивают в C++ строковые литералы; одинарные кавычки внутри них выводятся «как есть» в результирующую строку. Путаница кавычек или отсутствие некоторых пробелов сделает SVG некорректным.</p>
<p>Пусть начальная реализация графического вывода гистограммы всегда выводит пустое изображение фиксированного размера:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb11-2" title="2">show_histogram_svg(<span class="at">const</span> vector&lt;<span class="dt">size_t</span>&gt;&amp; bins) {</a>
<a class="sourceLine" id="cb11-3" title="3">    svg_begin(<span class="dv">400</span>, <span class="dv">300</span>);</a>
<a class="sourceLine" id="cb11-4" title="4">    svg_end();</a>
<a class="sourceLine" id="cb11-5" title="5">}</a></code></pre></div>
<p>Заменим вызов <code>show_histogram_text(bins)</code> вызовом <code>show_histogram_svg(bins)</code>.</p>
<p>Создать файл изображения можно так (можно скачать <a href="marks.txt"><code>marks.txt</code></a>):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">C</span>:\lab03-histogram<span class="op">&gt;</span> bin/Debug/lab03-histogram.exe <span class="op">&lt;</span>marks.txt <span class="op">&gt;</span>marks.svg</a></code></pre></div>
<p>В браузере <code>marks.svg</code> открывается из меню <em>Файл → Открыть…</em> Отобразится пустая страница (пустой рисунок). Можно нажать <em>Ctrl+U</em> или пункт <em>«Исходный код страницы»</em> в контекстном меню любого места страницы, чтобы увидеть результирующий код SVG.</p>
<h3 id="функции-вывода-элементов-svg">Функции вывода элементов SVG</h3>
<p>Для вывода подписей к столбцам напишем функцию вывода текста в SVG, которая принимает координату по горизонтали (<code>left</code>), координату нижнего края текста по вертикали (<code>baseline</code>) и сам текст:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span> svg_text(<span class="dt">double</span> left, <span class="dt">double</span> baseline, string text);</a></code></pre></div>
<p>Из введения в SVG выше известно, что она должна выводить строку такого формата:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">&lt;text</span><span class="ot"> x=</span><span class="st">&#39;20&#39;</span><span class="ot"> y=</span><span class="st">&#39;35&#39;</span><span class="kw">&gt;</span>anything you want<span class="kw">&lt;/text&gt;</span></a></code></pre></div>
<p>На C++ точно такую строку можно вывести следующим образом (<code>svg_text()</code>) должна размещаться выше <code>show_histogram_svg()</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb15-2" title="2">svg_text(<span class="dt">double</span> left, <span class="dt">double</span> baseline, string text) {</a>
<a class="sourceLine" id="cb15-3" title="3">    cout &lt;&lt; <span class="st">&quot;&lt;text x=&#39;20&#39; y=&#39;35&#39;&gt;anything you want&lt;/text&gt;&quot;</span>;</a>
<a class="sourceLine" id="cb15-4" title="4">}</a></code></pre></div>
<p>Чтобы вместо координаты <code>x</code> (числа 20) выводить значение <code>left</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">    cout &lt;&lt; <span class="st">&quot;&lt;text x=&#39;&quot;</span> &lt;&lt; left &lt;&lt; <span class="st">&quot;&#39; y=&#39;35&#39;&gt;anything you want&lt;/text&gt;&quot;</span>;</a></code></pre></div>
<p>Обратите внимание на то, что сохранены одинарные кавычки внутри строк C++ (в двойных кавычках) — они необходимы по правилам SVG.</p>
<ol start="7" class="example" type="1">
<li>Закончите реализацию <code>svg_text()</code>, чтобы подставлять значение координаты <code>baseline</code> и текст надписи <code>text</code>.</li>
</ol>
<p>Для проверки выведем высоту первого столбца гистограммы:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span></a>
<a class="sourceLine" id="cb17-2" title="2">show_histogram_svg(<span class="at">const</span> vector&lt;<span class="dt">size_t</span>&gt;&amp; bins) {</a>
<a class="sourceLine" id="cb17-3" title="3">    svg_begin(<span class="dv">400</span>, <span class="dv">300</span>);</a>
<a class="sourceLine" id="cb17-4" title="4">    svg_text(<span class="dv">20</span>, <span class="dv">20</span>, to_string(bins[<span class="dv">0</span>]));</a>
<a class="sourceLine" id="cb17-5" title="5">    svg_end();</a>
<a class="sourceLine" id="cb17-6" title="6">}</a></code></pre></div>
<p>Функция <code>to_string()</code> преобразует значения разных типов в строки.</p>
<p>Чтобы проверить модифицированную программу, её нужно запустить повторно:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1"><span class="ex">C</span>:\lab03-histogram<span class="op">&gt;</span> bin/Debug/lab03-histogram.exe <span class="op">&lt;</span>marks.txt <span class="op">&gt;</span>marks.svg</a></code></pre></div>
<p>После повторного запуска программы открытый в браузере файл можно обновить клавишей <em>F5.</em> На странице должен быть виден текст «2». Если в файле ошибка, он не отобразится. В этом случае нужно просмотреть код страницы на предмет ошибок в SVG, исправить код программы, перезапустить ее и проверить результат.</p>
<ol start="8" class="example" type="1">
<li><p>Напишите функцию для вывода прямоугольника в SVG:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height);</a></code></pre></div></li>
</ol>
<p>Для проверки выведем первый столбец гистограммы справа от подписи к нему:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1">    svg_rect(<span class="dv">50</span>, <span class="dv">0</span>, bins[<span class="dv">0</span>] * <span class="dv">10</span>, <span class="dv">30</span>);</a></code></pre></div>
<ol start="9" class="example" type="1">
<li>Убедитесь, что вывод первого столбца гистограммы работает.</li>
</ol>
<h3 id="исключение-магических-констант">Исключение «магических констант»</h3>
<p>Текст выводится в координатах <em>(20, 20)</em>, смещение левого края столбца <em>50</em> (оно же — ширина подписей), а высота столбца <em>30.</em> Эти числа подобраны так, чтобы элементы гистограммы не накладывались друг на друга, но они разбросаны по коду и их смысл неясен.</p>
<p>Прямо внутри функции <code>show_histogram_svg()</code> заведем константы:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="at">const</span> <span class="kw">auto</span> IMAGE_WIDTH = <span class="dv">400</span>;</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="at">const</span> <span class="kw">auto</span> IMAGE_HEIGHT = <span class="dv">300</span>;</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="at">const</span> <span class="kw">auto</span> TEXT_LEFT = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb21-4" title="4"><span class="at">const</span> <span class="kw">auto</span> TEXT_BASELINE = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb21-5" title="5"><span class="at">const</span> <span class="kw">auto</span> TEXT_WIDTH = <span class="dv">50</span>;</a>
<a class="sourceLine" id="cb21-6" title="6"><span class="at">const</span> <span class="kw">auto</span> BIN_HEIGHT = <span class="dv">30</span>;</a></code></pre></div>
<ol start="10" class="example" type="1">
<li>Замените «магические числа» константами и проверьте работу программы.</li>
</ol>
<h3 id="вывод-гистограммы">Вывод гистограммы</h3>
<p>Логика вывода гистограммы следующая: каждая корзина выводится так же, как первая, но к вертикальной координате добавляется смещение — высота столбца:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">double</span> top = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="cf">for</span> (<span class="dt">size_t</span> bin : bins) {</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="at">const</span> <span class="dt">double</span> bin_width = <span class="dv">10</span> * bin;</a>
<a class="sourceLine" id="cb22-4" title="4">    svg_text(TEXT_LEFT, top + TEXT_BASELINE, to_string(bin));</a>
<a class="sourceLine" id="cb22-5" title="5">    svg_rect(TEXT_WIDTH, top, bin_width, BIN_HEIGHT);</a>
<a class="sourceLine" id="cb22-6" title="6">    top += BIN_HEIGHT;</a>
<a class="sourceLine" id="cb22-7" title="7">}</a></code></pre></div>
<p>«Магическая константа» 10 пока сохраняется, потому что логика расчета ширины прямоугольника еще будет модифицироваться.</p>
<ol start="11" class="example" type="1">
<li>Реализуйте вывод гистограммы и проверьте работу программы.</li>
</ol>
<h3 id="оформление-гистограммы.-значения-параметров-по-умолчанию">Оформление гистограммы. Значения параметров по умолчанию</h3>
<p>Черная гистограмма не слишком эстетична или экономична при печати. За цвет линий в SVG отвечает атрибут <code>stroke</code>, а за цвет заливки — <code>fill</code>. Можно задать один из <a href="https://www.december.com/html/spec/colorsvghex.html">стандартных цветов</a> или выбрать цвет в формате <code>#RRGGBB</code> из <a href="http://getcolor.ru">палитры</a>. Пример прямоугольника с красными границами и бледно-розовой заливкой:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">&lt;rect</span><span class="ot"> x=</span><span class="st">&#39;50&#39;</span><span class="ot"> y=</span><span class="st">&#39;0&#39;</span><span class="ot"> width=</span><span class="st">&#39;30&#39;</span><span class="ot"> height=</span><span class="st">&#39;30&#39;</span><span class="ot"> stroke=</span><span class="st">&#39;red&#39;</span><span class="ot"> fill=</span><span class="st">&#39;#ffeeee&#39;</span><span class="kw">/&gt;</span></a></code></pre></div>
<ol start="12" class="example" type="1">
<li><p>Доработайте функцию <code>svg_rect()</code> для указания цвета линий и заливки:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb24-2" title="2">        string stroke, string fill);</a></code></pre></div></li>
<li><p>Измените цвета вывода и проверьте работу программы.</p></li>
</ol>
<h4 id="значения-параметров-по-умолчанию">Значения параметров по умолчанию</h4>
<p>Цвета элементов нужно задавать не всегда, а в текущей реализации у функции <code>svg_rect()</code> шесть параметров, два из которых отвечают за цвет. Можно было бы перегрузить функцию:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height);</a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb25-4" title="4">        string stroke, string fill);</a></code></pre></div>
<p>Однако в этом случае пришлось бы в каждой функции писать похожий код. В данном случае выгоднее применить значения параметров по умолчанию:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">void</span> svg_rect(<span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> width, <span class="dt">double</span> height,</a>
<a class="sourceLine" id="cb26-2" title="2">        string stroke = <span class="st">&quot;black&quot;</span>, string fill = <span class="st">&quot;black&quot;</span>);</a></code></pre></div>
<p>Значения по умолчанию указываются только один раз, обычно в определении функции (если объявление и определение отделены). Новая версия <code>svg_rect()</code> работает так:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>);             <span class="co">// svg_rect(0, 0, 100, 200, &quot;black&quot;, &quot;black&quot;);</span></a>
<a class="sourceLine" id="cb27-2" title="2">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="st">&quot;red&quot;</span>);      <span class="co">// svg_rect(0, 0, 100, 200, &quot;red&quot;,   &quot;black&quot;);</span></a>
<a class="sourceLine" id="cb27-3" title="3">svg_rect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="st">&quot;blue&quot;</span>, <span class="dv">4</span>);</a></code></pre></div>
<ol start="14" class="example" type="1">
<li><p>Добавьте значения параметров по умолчанию функции <code>svg_rect()</code>.</p></li>
<li><p>Сделайте коммит и отправите изменения на GitHub.</p></li>
<li><p><strong>(Домашнее задание.)</strong> Реализуйте для гистограммы в SVG масштабирование, как было сделано для текста в ЛР № 1. Опубликуйте коммит.</p></li>
</ol>
<h1 id="часть-3.-модульное-тестирование">Часть 3. Модульное тестирование</h1>
<p>Ранее для тестирования программы применялось перенаправление ввода и вывода. Такое тестирование называется функциональным. Однако функционального тестирования недостаточно для больших программ. Предположим, большая программа перестала выдавать правильный результат — как найти место ошибки? Необязательно это последнее изменение: возможно, другая часть и ранее работала неверно в некоторых случаях, и последняя правка лишь привела к такому случаю.</p>
<p>Модульное тестирование (unit testing) проверяет не работу всей программы, а работу отдельных ее компонент, например, отдельных функций. Модульные тесты пишутся программистами для собственного кода (функциональные тесты могут писаться или проводятся вручную другими специалистами).</p>
<p>Модульный тест — это отдельная программа, которая изолированно проверяет части кода основной программы. Если желательно протестировать части сложного алгоритма, эти части должны быть оформлены в виде отдельных функций (говорят: код должен быть <em>тестируемым).</em></p>
<h2 id="задача-1">Задача</h2>
<p>Написать модульный тест для функции поиска минимума и максимума.</p>
<h2 id="указания-2">Указания</h2>
<h3 id="выделение-тестируемой-функции-в-модуль">Выделение тестируемой функции в модуль</h3>
<p>Функция <code>find_minmax()</code> находится в основном (и единственном) модуле <code>main.cpp</code>. Для использования функции в других программах нужно вынести ее код в отдельный модуль. Модулем в практике C++ называется заголовочный файл (<code>*.h</code>) с объявлениями функций и файл реализации (<code>*.cpp</code>) с их определениями.</p>
<h4 id="создание-заголовочного-файла">Создание заголовочного файла</h4>
<ol start="17" class="example" type="1">
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту заголовочный файл <em>(C/C++ header).</em> Он должен быть расположен в каталоге проекта:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\histogram.h</code></p></li>
</ol>
<p>Заготовка файла включает «стража включения» (см. лекции):</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1"><span class="pp">#ifndef HISTOGRAM_H_INCLUDED</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="pp">#define H</span>ISTOGRAM_H_INCLUDED</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="pp">#endif </span><span class="co">// HISTOGRAM_H_INCLUDED</span></a></code></pre></div>
<p>Можно заменить его на более простой вариант <code>#pragma once</code> или писать код в этом файле между <code>#define</code> и <code>#endif</code>.</p>
<ol start="18" class="example" type="1">
<li>Перенесите функцию <code>find_minmax()</code> в <code>histogram.h</code>.</li>
</ol>
<p>Помимо самой функции в начало <code>histogram.h</code> (под <code>#pragma once</code>) нужно добавить подключение библиотеки векторов и стандартного пространства имен:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> std;</a></code></pre></div>
<p>Если теперь попытаться собрать программу, это не удастся: в файле <code>main.cpp</code> функция <code>find_minmax()</code> теперь отсутствует. Необходимо подключить файл <code>histogram.h</code> (в самом начале файла <code>main.cpp</code>):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a></code></pre></div>
<p>Обратите внимание на использование кавычек вместо угловых скобок: кавычки означают, что путь к файлу <code>*.h</code> написан относительно файла с <code>#include</code>, а угловые скобки предписывают искать включаемый файл по определенным в настройках путям.</p>
<ol start="19" class="example" type="1">
<li>Скомпилируйте программу и проверьте, что она работает.</li>
</ol>
<h4 id="создание-файла-реализации">Создание файла реализации</h4>
<ol start="20" class="example" type="1">
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту файл реализации <em>(C/C++ source).</em> Необходимые настройки:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\histogram.cpp</code><br />
<em>Add file to active project in build target(s)</em> — нажать <em>All.</em></p></li>
<li><p>В <code>histogram.cpp</code> подключите <code>histogram.h</code>.</p></li>
<li><p>Перенесите определение функции <code>find_minmax()</code> в <code>histogram.cpp</code>.</p></li>
<li><p>Оставьте в <code>histogram.h</code> от функции <code>find_minmax()</code> только объявление:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="dt">void</span> find_minmax(<span class="at">const</span> vector&lt;<span class="dt">double</span>&gt; numbers, <span class="dt">double</span>&amp; min, <span class="dt">double</span>&amp; max);</a></code></pre></div></li>
</ol>
<p>Если при выделении функции <code>find_minmax()</code> были использованы указатели, а не ссылки, объявление нужно соответствующим образом скорректировать.</p>
<ol start="24" class="example" type="1">
<li>Соберите программу и проверьте ее работу.</li>
</ol>
<h3 id="создание-проекта-для-модульных-тестов">Создание проекта для модульных тестов</h3>
<ol start="25" class="example" type="1">
<li><p>При помощи меню <em>File → New → Project…</em> создайте новый проект типа <em>Empty project.</em> Необходимые настройки:</p>
<p><em>Project title:</em> <code>lab03-test</code><br />
<em>Folder to create project in:</em> <code>C:\lab03-histogram</code><br />
<em>Project filename:</em> <code>lab03-test.cbp</code><br />
<em>Resulting filename:</em> <code>C:\lab03-histogram\lab03-test.cbp</code></p></li>
<li><p>Дважды щелкните по проекту <code>lab03-test</code>, чтобы сделать его активным.</p></li>
<li><p>Из контекстного меню проекта <code>lab03-test</code> выберите пункт <em>Add files…</em> и добавьте к проекту <code>histogram.h</code> и <code>histogram.cpp</code>. В открывшемся диалоге <em>Select the targets this file should belong to:</em> проставьте все флажки.</p></li>
<li><p>При помощи меню <em>File → New → File…</em> добавьте к проекту <code>lab03-test</code> файл реализации <em>(C/C++ source)</em> <code>test.cpp</code>. Необходимые настройки:</p>
<p><em>Filename with full path:</em> <code>C:\lab03-histogram\test.cpp</code><br />
<em>Add file to active project in build target(s)</em> — нажать <em>All.</em></p></li>
</ol>
<h3 id="написание-модульных-тестов">Написание модульных тестов</h3>
<p>Файл <code>test.cpp</code> представляет собой полноценную тестирующую программу, в которой подключен тестируемый модуль, библиотека с <code>assert()</code> (см. лекцию) и присутствует функция <code>main()</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></a>
<a class="sourceLine" id="cb32-4" title="4"></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb32-6" title="6">main() {</a>
<a class="sourceLine" id="cb32-7" title="7">}</a></code></pre></div>
<p>Первый тест будет проверять простой случай массива положительных чисел:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1"><span class="pp">#include </span><span class="im">&quot;histogram.h&quot;</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="dt">void</span></a>
<a class="sourceLine" id="cb33-6" title="6">test_positive() {</a>
<a class="sourceLine" id="cb33-7" title="7">    <span class="dt">double</span> min = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-8" title="8">    <span class="dt">double</span> max = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-9" title="9">    find_minmax({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}, min, max);</a>
<a class="sourceLine" id="cb33-10" title="10">    <span class="ot">assert</span>(min == <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb33-11" title="11">    <span class="ot">assert</span>(max == <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb33-12" title="12">}</a>
<a class="sourceLine" id="cb33-13" title="13"></a>
<a class="sourceLine" id="cb33-14" title="14"><span class="dt">int</span></a>
<a class="sourceLine" id="cb33-15" title="15">main() {</a>
<a class="sourceLine" id="cb33-16" title="16">    test_positive();</a>
<a class="sourceLine" id="cb33-17" title="17">}</a></code></pre></div>
<ol start="29" class="example" type="1">
<li><p>Соберите программу-тест, запустите ее и убедитесь, что она завершается без ошибок, то есть тест проходит.</p></li>
<li><p>Замените проверку <code>max == 3</code> на <code>max == 4</code>. Соберите и запустите программу, чтобы наблюдать образец вывода при провале теста. Верните правильную проверку.</p></li>
<li><p>Добавьте новые тесты (имена придумайте) на такие случаи:</p>
<ul>
<li>массив из трех отрицательных чисел;</li>
<li>массив из трех одинаковых чисел;</li>
<li>массив из одного числа.</li>
</ul>
<p>Убедитесь, что все тесты проходят.</p></li>
<li><p>Добавьте тест на обработку пустого массива и проверьте, проходит ли он.</p></li>
</ol>
<p>Если <code>find_minmax()</code> в своем начале обращается к <code>numbers[0]</code>, программа будет завершаться аварийно, так как для пустого массива <code>numbers[0]</code> нет.</p>
<p>Обратите внимание: тщательное написание модульных тестов позволило выявить случай, при котором код не работает. Выходом может быть такое поведение: в начале <code>find_minmax()</code> проверять длину массива (<code>numbers.size()</code>), и если она нулевая, возвращаться из функции без изменения <code>min</code> и <code>max</code>. Тест тогда может проверять, что в результате вызова <code>min</code> и <code>max</code> не меняются. Возможно, стоит также учесть случай пустого массива в основной программе.</p>
<ol start="33" class="example" type="1">
<li><p>Внесите исправления в <code>histogram.cpp</code> (как минимум), пересоберите основную программу и тест, убедитесь, что они работают.</p></li>
<li><p>Сделайте коммит со всеми новыми файлами и отправите изменения на GitHub.</p></li>
</ol>
<p><strong>Важно:</strong> перед коммитом не забудьте сохранить каждый проект <em>(File → Save project).</em></p>
<ol start="35" class="example" type="1">
<li><strong>(Домашнее задание.)</strong> Выделите в модуль все функци для работы с SVG, опубликуйте коммит.</li>
</ol>
    <hr/>
    <p>
		Козлюк&nbsp;Д.&nbsp;А., Мохов&nbsp;А.&nbsp;С., Василькова&nbsp;П.&nbsp;Д. для&nbsp;кафедры Управления и&nbsp;информатики НИУ &laquo;МЭИ&raquo;, 2019&nbsp;г.

        <span id="buttons">
            <!--LiveInternet counter--><script type="text/javascript"><!--
            document.write('<a href="http://www.liveinternet.ru/click" '+
            'target=_blank><img src="http://counter.yadro.ru/hit?t52.1;r'+
            escape(document.referrer)+((typeof(screen)=='undefined')?'':
            ';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+';u'+escape(document.URL)+
            ';i'+escape('Жж'+document.title.substring(0,80))+';'+Math.random()+
            '" alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа" '+
            'border=0 width=88 height=31 id="counter"><\/a>')//--></script><!--/LiveInternet-->

            <script type="text/javascript" src="/study/courses/assets/scripts/orphus.js"></script>
            <a href="http://orphus.ru" id="orphus" target="_blank"><img alt="Система Orphus" src="/study/courses/assets/images/orphus.gif" border="0" width="88" height="31" /></a>
	    </span>
    </p>
</body>
</html>
