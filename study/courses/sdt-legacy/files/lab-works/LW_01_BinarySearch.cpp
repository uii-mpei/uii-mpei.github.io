#include <cstdio>	// Стандартная библиотека ввода-вывода C.
#include <ctype.h>	// Функции определения типа символов (цифра, буква и т. п.).

int main()
{
	// Константа, определяющая максимальный размер массива. Тип size_t --
	// это беззнаковое целое, предпочтительное для размеров, индексов и т. п.
	const size_t MAX_ARRAY_SIZE = 42;

	// Объявление массива целых чисел со знаком размером 42.
	int array[MAX_ARRAY_SIZE];


	/* ЗАДАНИЕ: Вынесите ввод массива в функцию в отдельном файле. */

	// Объявим переменную size, куда будет занесено реальное число элементов,
	// и запросим у пользователя её ввод.
	size_t size;
	printf("Enter array size (n < %u): ", MAX_ARRAY_SIZE);
	scanf("%u", &size);

	// Ввод всех элементов массива через пробел.
	puts("Enter array elements (separated by spaces, e. g.: 1 2 3):");
	for (size_t i = 0; i < size; ++i)
	{
		scanf("%d", &array[i]);
	}


	/*
		Сортируем массив по возрастанию методом пузырька (bubble sort).
		Вот как может выглядеть массив на проходах цикла while
		(внутри каждого прохода (итерации) -- несколько итераций for):
			Начало:		4 2 5 1 3
			Проход 1:	2 4 5 1 3
						2 4 1 5 3
						2 4 1 3 5	Элемент 5 "всплыл" на свое место.
			Проход 2:	2 1 4 3 5
						2 1 3 4 5	На свое место "всплыл" элемент 4.
			Проход 3:	1 2 3 4 5	Массив стал упорядочен.
			Проход 4:	1 2 3 4 5	Перестановок не делается.

		ЗАДАНИЕ: Вынесите сортировку массива в функцию в отдельном файле.
	*/

	// Признак, что массив может быть еще не упорядочен.
	bool unsorted = true;

	// Пока массив *может быть* не упорядочен...
	while (unsorted)
	{
		// ...надеемся, что он окажется упорядочен на этот раз.
		unsorted = false;

		// Проходим по всем элементам массива, кроме последнего.
		for (size_t i = 0; i < size - 1; ++i)
		{
			// Если текущий элемент больше следующего (не упорядочены)...
			if (array[i] > array[i + 1])
			{
				// Меняем местами текущий и следующий элемент (упорядочиваем).
				int temporary = array[i];
				array[i] = array[i + 1];
				array[i + 1] = temporary;

				// Устанавливаем признак, что массив упорядочен не был.
				unsorted = true;
			}
		}
	}


	/* ЗАДАНИЕ: Вынесите вывод массива в функцию в отдельном файле. */

	// Вывод всех элементов массива в цикле.
	puts("Sorted array (ascending order):");
	for (size_t i = 0; i < size; ++i)
	{
		printf("%d ", array[i]);
	}
	// Перевод строки.
	puts("");


	/*
		В упорядоченном массиве можно искать элементы быстрее,
		чем просто просматривая их один за другим вплоть до искомого.
		Например, пусть ищется 5 в массиве [1 2 3 4 5 6 7].
		Возьмем элемент со средним индексом (6 + 0)/2 = 3, это 4.
		Так как 4 < 5, а массив упорядочен, имеет смысл искать 5
		только в части массива с индексами больше 3. Но эта задача
		ничем не отличается от исходной, кроме части массива, где ведется
		поиск, более того, обалсть поиска все время сужается.
		Если обозначить её границы как left (изначально 0) и
		right (изначально 6) и изменять их, данный алгоритм,
		называемый двоичным поиском, легко реализовать.
		Пример:
			1 2 3 4 5 6 7
			L			R	(0 + 6)/2 = 3, array[3] = 4, 4 < 5
			1 2 3 4 5 6 7
					L   R	(4 + 6)/2 = 5, array[5] = 6, 6 > 5
			1 2 3 4  5  6 7
					L=R		Область поиска выродилась в 1 элемент.

		ЗАДАНИЕ: Вынесите двоичный поиск в массиве в функцию в отдельном файле.
	*/

	// Бесконечный цикл do...while (true), чтобы пользователь мог найти
	// несколько элементов, которые его интересуют.
	do
	{
		// Объявляем переменную, содержающую число для поиска
		// и требуем у пользователя её ввести.
		int needle;
		printf("Enter an element to find: ");
		scanf("%d", &needle);

		// Область поиска:
		int left	= 0,					// левая граница;
			right	= size - 1, 			// правая граница;
			center	= (right + left) / 2;	// середина.
		// Почему не size_t? См. в комментариях ниже.
		// Объявлять так несколько переменных, вообще говоря, не поощряется,
		// так как это труднее читать, хотя изредка используется.

		do
		{
			// Если средний элемент -- искомый...
			if (array[center] == needle)
			{
				break;	// ...поиск можно завершать.
			}
			// Если элемент в середине области поиска меньше искомого,
			// левая граница должна лежать правее середины.
			else if (array[center] < needle)
			{
				left = center + 1;
			}
			// Иначе (элемент в середине больше искомого),
			// правая граница должна лежать левее середины.
			else
			{
				// Важно! В этом месте возможно right < 0. Это соответствует
				// алгоритму, однако, если бы right имел тип size_t (беззнаковый),
				// произошло бы переполнение (right стал бы большим положительным).
				right = center - 1;
			}

			// Вычисляем новый индекс среднего элемента.
			center = (left + right) / 2;
		}
		// Поиск идет, пока область поиска не выродится в 1 элемент.
		while (left < right);

		// Цикл мог завершиться в трех случаях:
		//	а) центарльный элемент оказался искомым;
		//	б) область поиска выродилась в 1 элемент, и он искомый;
		//	в) вариант б), но средний элемент НЕ искомый.
		// Поэтому нужно еще раз проверить средний элемент.
		if (array[center] == needle)
		{
			printf("Found %d at array[%u] = %d.\n", needle, center, array[center]);
		}
		else
		{
			puts("Not found.");
		}

		// Функция getchar() получает очередной введенный символ.
		// Ввод включает пробельные символы (переводы строк, например),
		// которые можно определить функцией isspace() из <ctype.h>.
		// Получение очередного символа ведется до тех пор, пока
		// не встретится непробельный символ ('y' или 'n').
		printf("Do you want to continue (y/n)? ");
		char answer;
		do
			answer = getchar();
		while (isspace(answer));

		if (answer == 'n')
		{
			break;	// Выход из бесконечного цикла do...while.
		}
		else if (answer != 'y')
		{
			// Ввод пользователя -- ни 'y', ни 'n', поэтому
			// будем считать, что продолжение требуется.
			puts("Let's just consider you do...");
		}

	} while (true);

	return 0;
}
