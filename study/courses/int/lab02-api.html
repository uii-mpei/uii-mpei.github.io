<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru-RU" xml:lang="ru-RU">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Лабораторная работа № 2. Приемы программирования сетевых приложений</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">Лабораторная работа № 2. Приемы программирования сетевых приложений</h1>
</div>
<h1 id="цель-работы"><span class="header-section-number">1</span> Цель работы</h1>
<p>Требуется:</p>
<ul>
<li>повторить средства C++ для работы с массивами (буферами), приведением типов, битовыми флагами и масками, представлением данных в памяти;</li>
<li>научиться компилировать и компоновать (собирать) программы, использующие сетевые API в Windows;</li>
<li>научиться обнаруживать и расшифровывать ошибки, возникающие в API сокетов.</li>
</ul>
<p>Предполагается, что вы знаете <a href="/study/courses/sdt/17/lecture01_intro.handouts.pdf">основы C++</a> и его средства <a href="/study/courses/sdt/17/lecture05_bits.slides.pdf">низкоуровневого программирования</a>.</p>
<p>Повторенные и полученные знания понадобятся как на последующих ЛР, так и при программировании сетевых приложений в целом.</p>
<h1 id="задание"><span class="header-section-number">2</span> Задание</h1>
<p><strong>Примечание.</strong> О языке программирования</p>
<p>В течение курса предлагается писать сетевые приложения на C++, и вот почему:</p>
<ul>
<li>язык позволяет напрямую обращаться с байтами, битами, указателями;</li>
<li>сетевые приложения уровня сокетов чаще всего пишут на C и C++, поэтому для них доступно больше примеров и литературы;</li>
<li>API сокетов стандартизировано и документировано для C.</li>
</ul>
<p>Вообще говоря, допускается выполнять задания на любом другом языке, но только при соблюдении условий:</p>
<ol style="list-style-type: decimal">
<li>Альтернативный язык и его средства согласованы с преподавателем.</li>
<li>Должно использоваться именно API сокетов (как его предоставляет язык). Например, для C# это класс <code>Socket</code> модуля <code>System.Net.Sockets</code>, но не <code>TcpClient</code>, <code>TcpServer</code>, <code>NetworkStream</code> того же модуля.</li>
<li>Программы должно быть возможно скомпилировать в лаборатории и выполнить с ними все задания (возможно, на собственном ноутбке и через Wi-Fi). Невозможность это сделать не может служить оправданием невыполнения работы.</li>
<li>При работе в бригаде все участники должны использовать один язык. Не допускается ссылаться на незнание альтернативного языка на защитах.</li>
</ol>
<h2 id="повторение-низкоуровневые-средства-c"><span class="header-section-number">2.1</span> Повторение: низкоуровневые средства C++</h2>
<ol class="example" style="list-style-type: decimal">
<li>Создайте учебный проект <code>lab02-recap</code>.</li>
</ol>
<p>Запустив CodeBlocks из меню «Пуск», создайте в ней новый проект <em>(File → New → Project…)</em> типа <em>Console application</em>, выбрав язык C++. Каталог проекта не должен включать пробелов и кириллических символов (на Windows XP).</p>
<p>Каждый пункт этого задания кратко напоминает определенный аспект C++ и требует написать короткую функцию-демонстрацию. Таким образом, итоговая программа должна иметь такую структуру:</p>
<pre><code>#include &lt;cstdio&gt;
// прочие #include…

void demo_something();  // объявление одной из функций-демонстраций
// аналогичные объявления…

int
main() {
    demo_something();  // вызов демонстрации
    // аналогичные вызовы…
}

// реализация демонстрации
void
demo_something() {
    // вывод имени функции
    puts(__func__);
    // код пункта задания
    // …
    // отделение вывода пустой строкой для удобства
    putchar(&#39;\n&#39;);
}

// прочие реализации…</code></pre>
<h3 id="типы-данных-фиксированного-размера-и-оператор-sizeof"><span class="header-section-number">2.1.1</span> Типы данных фиксированного размера и оператор <code>sizeof</code></h3>
<p>Стандарт C++ не определяет точный размер встроенных типов данных. Так, на практике переменная типа <code>long</code> может занимать 4 или 8 байтов. В сетевых протоколах же размеры полей строго фиксированы. Заголовочный файл <code>&lt;cstdint&gt;</code> определяет типы данных фиксированного размера:</p>
<ul>
<li><code>uint8_t</code> — байт или <em>октет</em> в сетевых терминах (когда зарождался интернет, еще активно использовались машины с размером «байта» не 8 бит);</li>
<li><code>uint16_t</code> — 16-битное «короткое» слово;</li>
<li><code>uint32_t</code> — 32-битное «длинное» слово.</li>
</ul>
<p>Размер любой переменной можно узнать оператором <code>sizeof</code>, например:</p>
<pre><code>printf(&quot;sizeof(int) = %d\n&quot;, sizeof(int));</code></pre>
<ol start="2" class="example" style="list-style-type: decimal">
<li><p>Напишите функцию <code>demo_size()</code> и добавьте в программу ее вызов. Функция должна демонстрировать работу с размерами типов:</p>
<ul>
<li>Объявить три переменных: октет <code>x</code>, «короткое» слово <code>y</code> и «длинное» слово <code>z</code> (понадобится подключить <code>&lt;cstdint&gt;</code>).</li>
<li>Напечатать размеры <code>x</code>, <code>y</code> и <code>z</code>.</li>
</ul></li>
</ol>
<h3 id="битовые-флаги"><span class="header-section-number">2.1.2</span> Битовые флаги</h3>
<p>Во многих местах API сокетов необходимо указывать некое подмножество возможных вариантов. Например, при приеме данных из сети можно, в частности:</p>
<ul>
<li>не ждать данных, а сразу получить ошибку, если их нет (<code>MSG_DONTWAIT</code>);</li>
<li>оставить данные доступными для следующего считывания (<code>MSG_PEEK</code>).</li>
</ul>
<p>Допускается не задействовать никакую из этих возможностей, задействовать одну или обе сразу. Чтобы указать нужный выбор (например, и то, и другое), используется одно целое значение, каждый бит которого означает, включена ли определенная опция во множество запрошенных. Упомянутый пример представлен так: <code>0b0100'0010</code>, где младшая единица значит <code>MSG_PEEK</code>, старшая — <code>MSG_DONTWAIT</code>.</p>
<p>Целое значение, в котором установлен один бит, отвечающий за элемент множества, называется флагом. Например флаг <code>MSG_PEEK</code> равен <code>2</code> (<code>0b0000'0010</code> или <code>0x02</code>), а <code>MSG_DONTWAIT</code> равен <code>0b0100'0000</code> или <code>0x40</code>.</p>
<p>Флаги комбинируются логическим <em>ИЛИ,</em> потому что оно оставляет в результате те биты, которые установлены хотя бы в одном операнде; то есть все биты, устанавливаемые флагами, окажутся в их комбинации:</p>
<pre><code>int flags = MSG_PEEK | MSG_DONTWAIT;</code></pre>
<p>Чтобы проверить наличие флага в комбинации, используется логическое <em>И,</em> потому что оно оставляет в результате только биты, установленные в обоих операндах; то есть, если во флаге установлен один бит, результат будет отличаться от нуля только в том случае, если бит присутствует и в комбинации:</p>
<pre><code>if (flags &amp; MSG_PEEK) {
    // Действия в случае, когда MSG_PEEK установлен.
}</code></pre>
<p>Побитовое отрицание флага, например, <code>~FLAG_GOOD</code> позволяет получить комбинацию, где указанный флаг сброшен, а остальные установлены. Побитовое <em>И</em> такой комбинации с любой другой сбрасывает этот флаг в результате.</p>
<p>Исключающее <em>ИЛИ</em> (XOR, <code>^</code>) комбинации и флага позволяет изменить состояние флага на противоположное (используется редко).</p>
<ol start="3" class="example" style="list-style-type: decimal">
<li><p>Напишите функцию <code>demo_flags()</code> и добавьте в программу ее вызов. Функция должна демонстрировать работу с флагами:</p>
<ul>
<li><p>Объявить набор констант-флагов:</p>
<pre><code>enum Flag : uint32_t {  // Флаги будут числами типа uint32_t:
    FLAG_QUICK = 0x01,  // - быстро
    FLAG_GOOD  = 0x02,  // - качественно
    FLAG_CHEAP = 0x04   // - недорого
};</code></pre></li>
<li><p>Объявить переменную, присвоив комбинацию любых двух флагов из трех:</p>
<pre><code>int flags = FLAG_GOOD | …;  // не обязательно FLAG_GOOD</code></pre></li>
<li><p>Проверить наличие в переменной-комбинации того флага, который включен в нее. Вывести <code>&lt;имя константы&gt; present</code>, если флаг обнаружен в комбинации; <code>&lt;имя константы&gt; absent</code>, если не обнаружен.</p>
<pre><code>if (flags &amp; FLAG_GOOD) {
    puts(&quot;FLAG_GOOD present&quot;);
} else {
    puts(&quot;FLAG_GOOD absent&quot;);
}</code></pre></li>
<li><p>Сделать то же самое для флага, который не включен в комбинацию.</p></li>
</ul></li>
</ol>
<h3 id="указатели"><span class="header-section-number">2.1.3</span> Указатели</h3>
<p>Все ячейки памяти, то есть байты, имеют номер, называемый <em>адресом.</em> <em>Указатель —</em> это переменная, содержащая адрес памяти. Подчеркнем, что адрес имеет смысл только в пределах машины и во время выполнения программы.</p>
<p>При наличии переменной можно получить ее адрес оператором <code>&amp;</code>:</p>
<pre><code>int variable = 42;          // int — целое число
int* pointer = &amp;variable;   // int* — указатель на целое число</code></pre>
<p>При наличии указателя можно обратиться к данным по адресу в нем оператором разыменования (<code>*</code>):</p>
<pre><code>printf(&quot;variable = %d\n&quot;, *pointer);    // 42
(*pointer) = 43;                        // variable = 43</code></pre>
<p>Это часто используется, чтобы организовать выходные параметры функций. Одним из параметров является указатель, по которому функция записывает полезное значение. Вызывающий код объявляет переменную и передает в такую функцию адрес этой переменной. После вызова функции значение переменной оказывается измененным.</p>
<ol start="4" class="example" style="list-style-type: decimal">
<li><p>Напишите функцию, которая записывает по адресу в <code>quotient</code> результат деления <code>x</code>, на <code>y</code>, а в <code>remainder</code> — остаток от деления <code>x</code> на <code>y</code> и возвращает <code>true</code>. Если <code>y</code> равна <code>0</code>, функция сразу возвращает <code>false</code>. Прототип функции:</p>
<pre><code>bool quot_rem(int x, int y, int* quotient, int* remainder);</code></pre>
<p><strong>Указание.</strong> Числа сравниваются <code>==</code>, остаток от деления берется <code>%</code>.</p></li>
<li><p>Напишите функцию <code>demo_pointers()</code> и добавьте в программу ее вызов. Функция должна демонстрировать работу с указателями:</p>
<ul>
<li>Объявить целочисленные переменные <code>quotient</code> и <code>remainder</code>.</li>
<li>Вызвать функцию <code>quot_rem()</code>, получая частное и остаток в объявленные переменные и печатая их значения после вызова:
<ul>
<li>с ненулевыми <code>x</code> и <code>y</code>;</li>
<li>с любым <code>x</code> и нулевым <code>y</code>.</li>
</ul></li>
</ul></li>
</ol>
<p>Есть специальное значение — нулевой указатель (<code>NULL</code>, читается «нал»), которое используется для индикации, что указатель не содержит адреса, по которому можно обратиться. Часто в API сокетов встречаются места, куда можно передать указатель, чтобы по нему записались полезные данные, или <code>NULL</code>, если эти данные не интересуют.</p>
<ol start="6" class="example" style="list-style-type: decimal">
<li>Доработайте <code>quot_rem()</code>: если <code>quotient</code> или <code>remainder</code> — нулевой, не записывайте данных по адресу в нем. Добавьте в <code>demo_pointers()</code> три новых вызова <code>quot_rem()</code>, где нулевыми указателями является <code>quotient</code>, <code>remainder</code> и обе сразу (а <code>y</code> — не нуль).</li>
</ol>
<p>Часто применяются указатели на неизменяемые данные, например:</p>
<pre><code>const int* readonly_pointer = &amp;variable;</code></pre>
<p>Их можно разыменовать, чтобы прочитать значение, на которое они указывают, не нельзя изменить это значение через указатель. Как правило, в виде таких указателей передаются входные параметры функций. Указатель на неизменяемые данные нельзя использовать так, где нужен обычный указатель.</p>
<p>Особый вид указателей — нетипизированные: <code>void*</code> и <code>const void*</code>. Они могут указывать на данные любого типа, соответственно, любой указатель можно использовать там, где требуется нетипизированный (с учетом <code>const</code>). Однако их нельзя разыменовать: неизвестен тип данных, который при этом получится. Как же использовать такие указатели? Технически любой указатель — просто число, которое можно интерпретировать как адрес данных любого же типа. Это называется приведением типов (type cast). Например, можно взять адрес целого числа, <em>привести</em> его к указателю на байты и рассмотреть байты, которые составляют целое число:</p>
<pre><code>int number = 42;
auto bytes = reinterpret_cast&lt;uint8_t*&gt;(&amp;number);
printf(&quot;%02x %02x %02x %02x\n&quot;, bytes[0], bytes[1], bytes[2], bytes[3]);</code></pre>
<p>(Ключевое слово <code>auto</code> сообщает компилятору вывести, то есть самому понять, тип переменной, в данном случае, <code>uint8_t*</code>. Само <code>auto</code> — не тип.)</p>
<p>В реальном коде часто встречается приведение в стиле C: <code>(uint8_t*)(&amp;number)</code>. Так как приведения типов слабо контролируются компилятором, а значит, чреваты ошибками, громоздкая и заметная конструкция <code>reinterpret_cast</code> предпочтительна.</p>
<h3 id="массивы"><span class="header-section-number">2.1.4</span> Массивы</h3>
<p>Массив — последовательно расположенные в памяти элементы одного типа.</p>
<p>Размер статических массивов известен на этапе компиляции и не меняется. Например, если программа готова принять из сети до 1,5 КБ данных, буфер для них можно объявить так (необходимо подключить <code>&lt;array&gt;</code>):</p>
<pre><code>std::array&lt;uint8_t, 1536&gt; buffer;</code></pre>
<p>Массивы <code>std::array</code> лучше массивов C (<code>uint8_t buffer[1536]</code>) дополнительными средствами для работы с ними, например, количество элементов можно узнать как <code>buffer.size()</code>.</p>
<p>Не следует объявлять очень большие (свыше нескольких тысяч элементов) статические массивы: они расходуют ограниченную область памяти под локальные переменные, называемую стеком. Исчерпание стека приведет к краху программы.</p>
<p><em>N. B.:</em> Размер массива (<code>sizeof(buffer)</code>) — не то же самое, что количество элементов в нем (<code>buffer.size()</code>); они совпадают только для байтовых массивов. Размер памяти под массив (в байтах) — произведение размера элемента на их количество.</p>
<p>Размер динамических массивов определяется только при работе программы. Например, часто сначала из сети принимается размер сообщения, затем выделяется динамический массив этого размера, в который принимается само сообщение. Для динамических массивов рекомендуются векторы из <code>&lt;vector&gt;</code>:</p>
<pre><code>std::vector&lt;uint8_t&gt; buffer;
// Между этипи строками каким-то образом выбирается размер size массива.
buffer.resize(size);</code></pre>
<p>Векторы автоматически освобождают занятую в процессе работы память.</p>
<p><em>N. B.</em> Размер самого вектора (<code>sizeof(buffer)</code>) никак не связан с количеством элементов в нем (<code>buffer.size()</code>). Размер памяти, занимаемой вектором, рассчитывается так же, как для массивов.</p>
<p>На элементы массивов можно создавать указатели:</p>
<pre><code>uint8_t* partial = &amp;buffer[1024];</code></pre>
<p>К указателям можно применять индексацию, например, <code>partial[0]</code> — то же самое, что <code>buffer[1024]</code>. Разумеется, при этом нельзя обращаться за пределы массива. К сожалению, C++ не пресекает такие попытки.</p>
<p><em>N. B.</em> Выход за пределы массив и порча тем посторонней памяти («расстрел памяти») — распространенная и очень опасная ошибка с непредсказуемыми последствиями. Сетевые приложения должны проверять корректность индексов.</p>
<p>Ключевые функции API сокетов для приема и передачи данных принимают, в числе прочих, два параметра: указатель на данные и количество байт, которые находятся по этому адресу — доступных для заполнения или готовых для отправки соответственно.</p>
<ol start="7" class="example" style="list-style-type: decimal">
<li><p>Напишите функцию <code>demo_arrays()</code> и добавьте в программу ее вызов. Функция должна демонстрировать работу с массивами:</p>
<ul>
<li>В начале программы необходимо подключить библиотеки: <code>#include &lt;array&gt;</code></li>
<li>В функции завести статический массив: <code>std::array&lt;int, 42&gt; static_buffer</code></li>
<li>Напечатать:
<ul>
<li><p>размер переменной-массива:</p>
<pre><code>printf(&quot;sizeof(static_buffer) = %d\n&quot;, sizeof(static_buffer));</code></pre></li>
<li><p>размер его элемента с индексом 0:</p>
<pre><code>printf(&quot;sizeof(static_buffer[0] = %d\n&quot;, sizeof(static_buffer[0]));</code></pre></li>
<li><p>количество элементов в массиве:</p>
<pre><code>printf(&quot;static_buffer.size() = %u\n&quot;, static_buffer.size());</code></pre></li>
<li><p>размер массива в байтах:</p>
<pre><code>printf(&quot;static_buffer takes %u bytes\n&quot;,
        static_buffer.size() * sizeof(static_buffer[0]));</code></pre></li>
</ul></li>
<li>Проделать то же самое, но для динамического массива <code>dynamic_buffer</code>.</li>
</ul></li>
<li><p>Напишите функцию для отображения указанного количества <code>count</code> байт памяти, расположенных по адресу <code>address</code>. Перед выводом собственно байт функция должна выводить отдельно значение <code>count</code> (например: <code>dumping 8 bytes</code>).</p>
<pre><code>void hex_dump(const void* address, size_t count);</code></pre></li>
</ol>
<p>Реализовать ее можно так:</p>
<ul>
<li>напечатать значение <code>count</code>;</li>
<li>привести <code>address</code> к указателю на байты (<code>const uint8_t*</code>):</li>
<li>в цикле по <code>i</code> от <code>0</code> до <code>count</code> (не включая) выводить <code>i</code>-й байт.</li>
<li>перейти на следующую строку, чтобы отделить вывод байт от последующего.</li>
</ul>
<p>Функция понадобится в последующих пунктах.</p>
<h3 id="структуры-и-выравнивание"><span class="header-section-number">2.1.5</span> Структуры и выравнивание</h3>
<p>Структура — определяемый пользователем тип данных, содержащий несколько именованных членов-переменных (полей), которые хранятся вместе:</p>
<pre><code>// Показания датчика.
struct Metric {
    uint32_t time;    // время съема, секунд с 00:00:00 01.01.1970 GMT
    char sensor[10];  // имя датчика (до 9 символов и завершающий &#39;\0&#39;)
    float value;      // значение показателя
};</code></pre>
<p>Структуры объявляются как обычные переменные, а обращения к их полям делается через точку:</p>
<pre><code>Metric metric;
metric.time = time(NULL);
strcpy(metric.sensor, &quot;cpu0&quot;);
metric.value = 59.4f;</code></pre>
<p>Если имеется указатель на структуру, к полям удобно обращаться оператором-стрелкой:</p>
<pre><code>Metric* pointer = &amp;metric;
pointer-&gt;time += 42;        // (*pointer).time += 42;</code></pre>
<p>Для оптимизации компилятор может применять выравнивание: вставлять между членами структуры неиспользуемое пространство, чтобы они оказались в памяти по адресам, кратным 4, 8 или 16.</p>
<ol start="9" class="example" style="list-style-type: decimal">
<li><p>Напишите функцию <code>demo_alignment()</code> и добавьте в программу ее вызов.</p>
<ul>
<li>Объявите структуру <code>Metric</code>. (Обычно типы не объявляют внутри функций, но это не запрещается языком и в данном случае удобно.)</li>
<li>Объявите переменную типа <code>Metric</code> и заполните ее, как показано. Функция <code>time()</code> объявлена в <code>&lt;ctime&gt;</code>, <code>strcpy()</code> — в <code>&lt;cstring&gt;</code>.</li>
<li><p>Выведите значения полей структуры:</p>
<pre><code>printf(&quot;metric.time = %u\n&quot;, metric.time);
printf(&quot;metric.sensor = &#39;%s&#39;\n&quot;, metric.sensor);
printf(&quot;metric.value = %f\n&quot;, metric.value);
hex_dump(&amp;metric, sizeof(metric));</code></pre></li>
<li><p>Выведите байты памяти, которую занимает переменная <code>metric</code>.</p></li>
</ul></li>
</ol>
<p>Выравнивание определяется компилятором. Если скомпилировать одну и ту же программу для разных машин разными компиляторами (или с разными настройками), выравнивание может измениться. И тогда, если отправить байты структуры в сеть, на другой машине нельзя интерпретировать эти байты как структуру, потому что одно и то же поле имеет разное смещение от начала структуры в зависимости от выравнивания.</p>
<ol start="10" class="example" style="list-style-type: decimal">
<li><p>Убедитесь, что выравнивание может создавать описанную проблему, создав аналогичные структуры и попытавшись совместить их представление в памяти. (Изменения вносите в <code>demo_alignment()</code>.)</p>
<ul>
<li><p>Окружите структуру <code>Metric</code> директивами компилятора, жестко задающими выравнивание на 8 байт (для воспроизводимости эксперимента):</p>
<pre><code>#pragma pack(push, 8)
struct { … };
#pragma pack(pop)</code></pre></li>
<li>Объявите ниже точно такую же структуру, но под именем <code>Metric2</code> и с отключенным выравниванием, то есть с выравниванием на 1 байт.</li>
<li><p>Интерпретируйте память, занимаемую <code>metric</code>, как байты:</p>
<pre><code>uint8_t* bytes = reinterpret_cast&lt;uint8_t*&gt;(&amp;metric);</code></pre></li>
<li><p>Затем интерпретируйте эти байты как <code>Metric2</code>:</p>
<pre><code>Metric2* metric2 = reinterpret_cast&lt;Metric2*&gt;(bytes);</code></pre></li>
<li><p>Выведите значения полей <code>metric2</code> и байты памяти, которые <code>metric2</code> занимает (при вызове <code>hex_dump()</code> помните, что <code>metric</code> была структурой, а <code>metric2</code> — уже указатель на структуру).</p></li>
</ul></li>
</ol>
<p>В отчете дополнительно отметьте неиспользуемые байты выравнивания в <code>metric</code>.</p>
<p>В сетевых протоколах обычно либо не допускается выравнивания, либо, наоборот, выравнивание есть и строго задано, то есть расположение данных в памяти (и в пакете) фиксировано.</p>
<h3 id="порядок-байт-в-машинном-слове-byte-order-endianness"><span class="header-section-number">2.1.6</span> Порядок байт в машинном слове (byte-order, endianness)</h3>
<p>При записи чисел принято писать старшие разряды в начале, например, 513 — сначала сотни (5), затем десятки (1), затем единицы (3). В памяти минимально адресуемая единица не разряд, а байт, то есть 513 (в шестнадцатеричной системе <code>0x0201</code>) представлено как два байта: <code>0x02</code> и <code>0x01</code>. В памяти их можно расположить как <code>0x02</code>, <code>0x01</code> — от старшего к младшему (big-endian) или как <code>0x01</code>, <code>0x02</code> — от младшего к старшему (little-endian). Это выбирают разработчики процессора, а программисту их выбор безразличен: пока работа ведется через переменные, внутреннее представление всегда будет использоваться одно и то же.</p>
<p>При передаче данных по сети нет переменных — только байты. Возникает неоднозначность, как трактовать целое число, пришедшее по сети в виде нескольких байтов (например, <code>0x01</code>, <code>0x02</code>): как big-endian (тогда это <code>0x0102</code> = 258) или как little-endian (тогда это <code>0x0201</code> = 513). По сети могут передаваться данные между машинами, процессоры которых используют разный порядок байт, поэтому нужна договоренность заранее. Эта договоренность описывается как часть любого двоичного протокола.</p>
<p>Исторически сложилось, что большинство протоколов используют big-endian, поэтому его еще называют сетевым порядком байт (network byte-order). «Сетевой» — это термин, сама по себе передача по сети не влияет на порядок байт. Архитектура x86 (процессоры Intel и AMD) использует little-endian.</p>
<p>В API сокетов входят функции для преобразования порядка байт: <code>htons</code>, <code>htonl</code>, <code>ntohs</code> и <code>ntohl</code>. Названия расшифровываются по такой схеме: <strong>h</strong>ost <strong>to</strong> <strong>n</strong>etwork [for] <strong><code>l</code></strong><code>ong</code> — из порядка байт хоста в сетевой порядок байт для длинного целого (4 байта); двухбайтовые целые называются <strong><code>s</code></strong><code>hort</code>. Функции объявлены в <code>&lt;winsock2.h&gt;</code>.</p>
<ol start="11" class="example" style="list-style-type: decimal">
<li><p>Расшифруйте названия оставшихся трех функций и занесите в отчет.</p></li>
<li><p>Напишите функцию <code>demo_byte_order()</code> и добавьте в программу ее вызов. В функции нужно продемонстрировать работу с порядком байт для 16- и 32-битного целого. Для 16-битного код приведен, для 32-битного добавьте код самостоятельно.</p>
<ul>
<li><p>Завести две целочисленные переменные и дать им произвольные значения, чтобы все байты были ненулевыми:</p>
<pre><code>uint16_t host2 = 0x2018;</code></pre></li>
<li><p>Вывести значения переменных и байты, составляющие их (<code>%04x</code> — вывод в шестнадцатеричном виде (<code>x</code>) четырех цифр с ведущими нулями):</p>
<pre><code>printf(&quot;host2 = %04x\n&quot;, host2);
hex_dump(&amp;host2, sizeof(host2));</code></pre></li>
<li><p>Преобразовать значения в сетевой порядок байт:</p>
<pre><code>uint16_t net2 = htons(host2);</code></pre></li>
<li><p>Вывести преобразованные значения и их байты:</p>
<pre><code>printf(&quot;net2 = %04x\n&quot;, net2);
hex_dump(&amp;net2, sizeof(net2));</code></pre></li>
</ul></li>
</ol>
<p><strong>Предупреждение.</strong> У вас не получится собрать программу, использующую <code>htons()</code> и ей подобные функции. Данный пункт необходимо довести со состояния, когда останутся две ошибки <code>undefined reference</code>.</p>
<ol start="13" class="example" style="list-style-type: decimal">
<li>Сохраните проект и продолжайте выполнять задания. По завершении следующего раздела вернитесь и доведите программу до работоспособного состояния. Переключение между проектами в CodeBlocks делается двойным щелчком по ним.</li>
</ol>
<h2 id="сборка-программ-использующих-api-сокетов"><span class="header-section-number">2.2</span> Сборка программ, использующих API сокетов</h2>
<ol start="14" class="example" style="list-style-type: decimal">
<li><p>Создайте новый проект — <code>lab02-api</code>.</p></li>
<li><p>Подключите к программе API сокетов, добавив вверху файла <code>main.cpp</code>:</p>
<pre><code>#include &lt;winsock2.h&gt;</code></pre></li>
<li><p>Внутри функции <code>main()</code> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms742213(v=vs.85).aspx">инициализируйте</a> API сокетов:</p>
<pre><code>// Инициализировать API сокетов (ws2_32.dll).
WSADATA wsa;
WSAStartup(MAKEWORD(2, 2), &amp;wsa);

// Код, работающий с сетью, должен размещаться здесь или вызываться отсюда.

// Завершить работу с API сокетов (ws2_32.dll).
WSACleanup();</code></pre></li>
</ol>
<ol start="17" class="example" style="list-style-type: decimal">
<li><p>Попытайтесь собрать программу <em>(клавиши Ctrl+F9</em>, пункт меню <em>Build → Build</em> или кнопка на панели инструментов).</p>
<p>Скопируйте содержимое вкладки <em>Build Log</em> в отчет.</p></li>
</ol>
<p>Программа компилируется, но не компонуется (не линкуется). Это можно видеть во вкладке <em>Build Log</em> ниже исходного кода: первая команда компиляции <code>g++.exe … -c …\main.cpp -o …\main.o</code> прошла успешно, а команда компоновки <code>g++.exe -o …\lab02-api.exe …\main.o …</code> завершилась с ошибками. Текст ошибок сообщает об <code>unresolved reference</code> — неразрешенных ссылках, то есть о вызовах функций, машинного кода которых нет ни в программе, ни в стандартных библиотеках. Ошибки указывают на конкретные функции — задействованные нами <code>WSAStartup()</code> и <code>WSACleanup()</code>.</p>
<ol start="18" class="example" style="list-style-type: decimal">
<li>Добавьте недостающие библиотеки с API сокетов в компоновку.</li>
</ol>
<p>Откройте диалог настроек сборки проекта <em>(Project → Build options…)</em>. В дереве слева выберите верхний узел <code>lab02-api</code>: библиотека нужна как в отладочной сборке (<code>Debug</code>), так и в фильной (<code>Release</code>). На вкладке <em>Linker settings</em> кнопкой <em>Add</em> добавьте в список библиотек <em>(Link libraries)</em> нужную — <code>ws2_32</code> (без расширения).</p>
<p>Имя библиотеки программисты узнают из <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms737629(v=vs.85).aspx">документации</a> (пункт 4).</p>
<ol start="19" class="example" style="list-style-type: decimal">
<li>Убедитесь, что теперь программа собирается.</li>
</ol>
<h2 id="использование-api-сокетов"><span class="header-section-number">2.3</span> Использование API сокетов</h2>
<p>В качестве примера API сокетов рассмотрим функции для диагностики ошибок. Они крайне важны потому, что к надежности сетевых программ предъявляются повышенные требования. Сетевые приложения часто работают долгое время без остановки, поэтому недопустимы утечки ресурсов (выделение без освобождения), в том числе при ошибках, а значит, ошибки должны аккуратно обрабатываться.</p>
<h3 id="глобальный-код-ошибки"><span class="header-section-number">2.3.1</span> Глобальный код ошибки</h3>
<p>Практически любое действие, связанное с сетью, может привести к ошибке. Как правило, функции в случае ошибки возвращают особое значение (часто <code>-1</code>, но не всегда) и выставляют глобальный (для потока) числовой код ошибки. Его можно получить функцией <code>WSAGetLastError()</code> в Windows или из переменной <code>errno</code> в *nix. Описания кодов сведены в <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740668(v=vs.85).aspx">таблицу</a> (Windows) или перечислены на <a href="https://linux.die.net/man/7/socket"><code>man</code>-страницах</a> (*nix).</p>
<p>Очень важно понимать, что глобальный код ошибки используется не только API сокетов, и успешные вызовы сбрасывают его в 0. Между вызовом API сокетов и проверкой кода ошибке не должно быть кода, обращающегося к системным API, которые могут код ошибки изменить. Например, вот неверный код:</p>
<pre><code>auto channel = socket(0x12, 0x34, 0x56);  // Некорректный API сокетов.
if (channel == INVALID_SOCKET) {
    cerr &lt;&lt; &quot;Error code: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Действие <code>cerr &lt;&lt; &quot;Error code: &quot;</code> выводит данные на экран, то есть обращается к системному API (для жоступа к экрану). Обычно это происходит успешно, и глобальный код ошибки сбрасывается в <code>0</code>. Правильный код:</p>
<pre><code>auto channel = socket(0x12, 0x34, 0x56);
if (channel == INVALID_SOCKET) {
    int error = WSAGetLastError();
    cerr &lt;&lt; &quot;Error code: &quot; &lt;&lt; error &lt;&lt; &#39;\n&#39;;
}</code></pre>
<p>Здесь код ошибки запоминается сразу после проблемного вызова, поэтому дальнейший сброс его уже не имеет значения.</p>
<ol start="20" class="example" style="list-style-type: decimal">
<li>Добавьте корректный вариант кода в программу. Запустите ее, чтобы получить код ошибки, и занесите его в отчет. По таблице определите, как называется константа для этого кода, каков его смысл, и добавьте это в отчет.</li>
</ol>
<h3 id="код-ошибки-отдельного-сокета"><span class="header-section-number">2.3.2</span> Код ошибки отдельного сокета</h3>
<p>Сокет — это идентификатор устройства для связи по сети, подобно тому, как файловый дескриптор является идентификатором устройства (файла) на диске. Например, через переменную-сокет ведется работа с отдельным подключением.</p>
<p>Некоторые операции работают с несколькими сокетами (например, ожидание прибытия данных по одному из них), поэтому при ошибках по глобальному коду нельзя определить, с каким именно сокетом возникла проблема. В таких случаях есть возможность получить код последней ошибки конкретного сокета.</p>
<p>Следующий код создает сокет <code>channel</code>:</p>
<pre><code>auto channel = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</code></pre>
<ol start="21" class="example" style="list-style-type: decimal">
<li>Исправьте в программе вызов <code>socket()</code> на правильный. Запустите программу, опишите и обоснуйте в отчете результат ее выполнения.</li>
</ol>
<p>Без полноценного сетевого взаимодействия затруднительно вызывать сбой сокета. Просто получим код ошибки сокета в переменную <code>error</code> (он будет нулевым, так как ошибки нет):</p>
<pre><code>int error = 0;
int length = sizeof(error);
getsockopt(channel, SOL_SOCKET, SO_ERROR, (char*)&amp;error, &amp;length);
printf(&quot;Socket error (code %d)!\n&quot;, error);</code></pre>
<ol start="22" class="example" style="list-style-type: decimal">
<li><p>Добавьте в программу код для получения ошибки сокета. Запустите программу и занесите в отчет результат ее выполнения.</p></li>
<li><p>Функция <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms738544(v=vs.85).aspx"><code>getsockopt()</code></a> сама по себе может завершиться с ошибкой (см. раздел <em>Return value).</em> Добавьте в программу код, который обрабатывает ее.</p></li>
<li><p>Изучите разделы <em>Parameters</em> и <em>Remarks</em> документации на <code>getsockopt()</code>. Опищите в отчете, почему функиця должна быть вызвана именно с приведенными значениями параметров.</p></li>
</ol>
<h1 id="контрольные-вопросы-и-задания"><span class="header-section-number">3</span> Контрольные вопросы и задания</h1>
<ol>
<li><p>Почему для битовых флагов используются значения <code>0x01</code>, <code>0x02</code>, <code>0x04</code> и тому подобные (а не просто <code>1</code>, <code>2</code>, <code>3</code>, например)?</p></li>
<li><p>Запишите выражение для получения из комбинации флагов <code>flags</code> такой же, но со сброшенным флагом <code>FLAG_GOOD</code> (не важно, был ли он уже сброшен).</p></li>
<li><p>Запишите выражение для получения из комбинации флагов <code>flags</code> такой же, но где флаг <code>FLAG_GOOD</code> установлен, если он был сброшен, и сброшен, если он был установлен.</p></li>
<li><p>Каков размер указателя, от чего это зависит и от чего не зависит (для платформы x86_64)?</p></li>
<li><p>Требуется ли учитывать и менять порядок байтов для указателей? Если да, когда и как; если нет, почему?</p></li>
<li><p>Можно ли через приведение типов получить доступ к данным явно некорректным образом, например, рассмотреть дробное число как текст? Ответ обоснуйте.</p></li>
<li><p>Имеется массив <code>buffer</code> (<code>std::array</code> или <code>std::vector</code>). Запишите вызов функции <code>hex_dump()</code>, позволяющий напечатать байты памяти, которая занята элементами <code>buffer</code>, начиная с 512. Размер массива допускается узнавать, используя только сам <code>buffer</code> и операции над ним.</p></li>
<li><p>Может ли запись значений в массив по индексам, большим его размера, привести к негативным последствиям, и если да, к каким? (Исследуйте варианты в сети или предложите обоснуйте теоретически.)</p></li>
<li><p>Имеется связанный список, узлы которого — упакованные структуры с полем-указателем на следующий элемент и текстовыми даннными. Можно ли, и почему, передавать по сети узлы списка (байты памяти, которую они занимают), принимать их и использовать «как есть»?</p></li>
<li><p>Отправитель формирует в памяти упакованную структуру <code>Metric</code> и отправляет блок памяти с ней по сети. Получатель считывает эти байты, приводит указатель на них к типу <code>Metric*</code> и использует как структуру. Корректен ли такой протокол в общем случае (для любых двух платформ)? Если да, чем это гарантируется; если нет, как исправить?</p></li>
<li><p>Нужно ли при передаче по сети полей-комбинаций флагов учитывать порядок байтов в машинном слове? Если да, в каких случаях; если нет, почему?</p></li>
<li><p>Требуется ли учитывать и менять порядок байтов для <code>uint8_t</code> и <code>float</code>? Если да, каким образом; если нет, почему?</p></li>
<li><p>Ознакомьтесь с документацией на <code>WSAStartup()</code>. Что означает первый параметр функции? Как можно сформировать его без макроса <code>MAKEWORD()</code>?</p></li>
<li><p>Как можно диагностировать ситуацию, когда до начала работы с API сокетов не сделан вызов <code>WSAStartup()</code>, и как проверять ошибки самой этой функции?</p></li>
<li><p>Что такое утечка ресурсов (приведите не менее трех примеров) и какие негативные последствия она может повлечь?</p></li>
</ol>
</body>
</html>
